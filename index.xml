<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aimless</title>
    <link>http://aimless.jp/</link>
    <description>Recent content on Aimless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 18 Jul 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://aimless.jp/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>API Gateway &#43; Lambdaを使って、マルチクラウド管理APIを作る</title>
      <link>http://aimless.jp/blog/archives/2679</link>
      <pubDate>Sat, 18 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2679</guid>
      <description>&lt;p&gt;「単一のREST APIで複数のクラウドを操作できたら便利だろうなー」と思い調べてみたところ、以下のようなライブラリを見つけました。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語&lt;/th&gt;
&lt;th&gt;ライブラリ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ruby&lt;/td&gt;
&lt;td&gt;DeltaCloud&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;libcloud&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Node.js&lt;/td&gt;
&lt;td&gt;pkgcloud&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Golang&lt;/td&gt;
&lt;td&gt;Gophercloud&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　ライブラリによってサポートするクラウドプロバイダーが異なり、さらに管理できるサービスと管理できないサービスがあります。どれか一つのライブラリと心中するのは、少々リスクだと思いました。&lt;/p&gt;

&lt;p&gt;　「何か他にいい方法はないかなー」と調べていたところに、Amazon API Gatewayがリリースされました。API Gatewayを利用すると、API Gateway経由でLambdaを実行することができます。LambdaではNode.jsとjavaが動きます。主要なクラウドにはNode.jsやjavaのSDKが存在します。つまり、API Gatewayを利用すれば、自分のやりたいことができる、マルチクラウド管理APIを作れそうな気がしました。&lt;/p&gt;

&lt;p&gt;　というわけで実践。AzureとAWSのインスタンス情報をまとめて返すAPIを作ってみます。&lt;/p&gt;

&lt;p&gt;　API Gatewayでは、/computeがGETされた場合にLambdaファンクションを発火するようにします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/07/api_gateway_setting.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;　そして、対応するLambdaファンクションでは以下のコードを動かします。SDKを利用して各クラウドのインスタンス情報を取得し配列に格納し、その配列を返すスクリプトです。&lt;/p&gt;

&lt;p&gt;　とりあえずということで、認証情報の扱いは適当です。AWSの認証情報はコード内にベタ書きします。Azureの証明書は、lambdaファンクションのZIPに含めます。実際のところは、API Gatewayにアクセスする際のHTTPヘッダに認証情報を含め、Lambdaファンクションに渡す方法がカッコいいと思います。&lt;/p&gt;

&lt;p&gt;　ブラウザでAPI Gatewayの/computeにアクセスすると、以下のJSONが返ってきます。AzureとAWSのインスタンス情報が一つのJSONのレスポンスになっています。いい感じですね。このレスポンスをJavascriptでいい感じに表示するHTMLを作ってS3に配置すれば、サーバレスのマルチクラウド管理ポータルが作れるかも？&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/07/result_of_api.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rails4でRedmine CORSを使う</title>
      <link>http://aimless.jp/blog/archives/2669</link>
      <pubDate>Tue, 07 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2669</guid>
      <description>

&lt;h2 id=&#34;やりたいこと:273ca993f084584514ef76dff312aa4b&#34;&gt;やりたいこと&lt;/h2&gt;

&lt;p&gt;　Cross-Origin Resource SharingでRedmineのデータを取得する&lt;/p&gt;

&lt;h2 id=&#34;実現方法:273ca993f084584514ef76dff312aa4b&#34;&gt;実現方法&lt;/h2&gt;

&lt;p&gt;　&lt;a href=&#34;https://github.com/mavimo/redmine_cors&#34;&gt;Redmine CORS&lt;/a&gt;を使い、RedmineをCORSに対応させる&lt;/p&gt;

&lt;h2 id=&#34;やってみたこと:273ca993f084584514ef76dff312aa4b&#34;&gt;やってみたこと&lt;/h2&gt;

&lt;p&gt;　READMEに記載されている方法でやってみたところ、以下の環境では動作しませんでした。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Environment:
  Redmine version                3.1.0.devel
  Ruby version                   2.2.2-p95 (2015-04-13) [x86_64-linux]
  Rails version                  4.2.3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　具体的にはプラグインのマイグレーション時に以下のエラーメッセージが出ます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ mogok rake redmine:plugins:migrate                   
Running &amp;#039;rake redmine:plugins:migrate&amp;#039;...
2015-07-07T20:56:44+09:00 console[app3014.29]: An error occurred while loading the routes definition of redmine_cors plugin (/app/plugins/redmine_cors/config/routes.rb): You should not use the `match` method in your router without specifying an HTTP method.
2015-07-07T20:56:44+09:00 console[app3014.29]: If you want to expose your action to both GET and POST, add `via: [:get, :post]` option.
2015-07-07T20:56:44+09:00 console[app3014.29]: If you want to expose your action to GET, use `get` in the router:
2015-07-07T20:56:44+09:00 console[app3014.29]:   Instead of: match &#34;controller#action&#34;
2015-07-07T20:56:44+09:00 console[app3014.29]:   Do: get &#34;controller#action&#34;.
&lt;/code&gt;&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　エラーメッセージに言われるがまま、以下の箇所のmatchをgetにかえると、プラグインのマイグレーションは成功します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ more plugins/redmine_cors/config/routes.rb 
RedmineApp::Application.routes.draw do
  match &amp;#039;*path&amp;#039;, :to =&amp;gt; &amp;#039;cors#preflight&amp;#039;, :constraints =&amp;gt; {:method =&amp;gt; &amp;#039;OPTIONS&amp;#039;}
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　ただし、ルーティングがないというエラーメッセージが出て、結局動作しません。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-07-07T20:00:46+09:00 app[app3012.03]: ActionController::RoutingError (No route matches [OPTIONS] &#34;/users/current.json&#34;):
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/actionpack-4.2.3/lib/action_dispatch/middleware/debug_exceptions.rb:21:in `call&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/actionpack-4.2.3/lib/action_dispatch/middleware/show_exceptions.rb:30:in `call&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/railties-4.2.3/lib/rails/rack/logger.rb:38:in `call_app&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/railties-4.2.3/lib/rails/rack/logger.rb:20:in `block in call&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/activesupport-4.2.3/lib/active_support/tagged_logging.rb:68:in `block in tagged&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/activesupport-4.2.3/lib/active_support/tagged_logging.rb:26:in `tagged&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/activesupport-4.2.3/lib/active_support/tagged_logging.rb:68:in `tagged&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/railties-4.2.3/lib/rails/rack/logger.rb:20:in `call&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/actionpack-4.2.3/lib/action_dispatch/middleware/request_id.rb:21:in `call&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/rack-1.6.4/lib/rack/methodoverride.rb:22:in `call&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/rack-1.6.4/lib/rack/runtime.rb:18:in `call&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/activesupport-4.2.3/lib/active_support/cache/strategy/local_cache_middleware.rb:28:in `call&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/actionpack-4.2.3/lib/action_dispatch/middleware/static.rb:116:in `call&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/rack-1.6.4/lib/rack/sendfile.rb:113:in `call&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/railties-4.2.3/lib/rails/engine.rb:518:in `call&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/railties-4.2.3/lib/rails/application.rb:165:in `call&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/railties-4.2.3/lib/rails/railtie.rb:194:in `public_send&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   .bundle/gems/ruby/2.2.0/gems/railties-4.2.3/lib/rails/railtie.rb:194:in `method_missing&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   /opt/ruby-2.2.2-1/lib/ruby/site_ruby/2.2.0/thin/connection.rb:86:in `block in pre_process&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   /opt/ruby-2.2.2-1/lib/ruby/site_ruby/2.2.0/thin/connection.rb:84:in `catch&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   /opt/ruby-2.2.2-1/lib/ruby/site_ruby/2.2.0/thin/connection.rb:84:in `pre_process&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   /opt/ruby-2.2.2-1/lib/ruby/site_ruby/2.2.0/thin/connection.rb:53:in `process&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   /opt/ruby-2.2.2-1/lib/ruby/site_ruby/2.2.0/thin/connection.rb:39:in `receive_data&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   /opt/ruby-2.2.2-1/lib/ruby/site_ruby/2.2.0/eventmachine.rb:187:in `run_machine&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   /opt/ruby-2.2.2-1/lib/ruby/site_ruby/2.2.0/eventmachine.rb:187:in `run&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   /opt/ruby-2.2.2-1/lib/ruby/site_ruby/2.2.0/thin/backends/base.rb:73:in `start&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   /opt/ruby-2.2.2-1/lib/ruby/site_ruby/2.2.0/thin/server.rb:162:in `start&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   /opt/ruby-2.2.2-1/lib/ruby/site_ruby/2.2.0/thin/controllers/controller.rb:87:in `start&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   /opt/ruby-2.2.2-1/lib/ruby/site_ruby/2.2.0/thin/runner.rb:199:in `run_command&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   /opt/ruby-2.2.2-1/lib/ruby/site_ruby/2.2.0/thin/runner.rb:155:in `run!&amp;#039;
2015-07-07T20:00:46+09:00 app[app3012.03]:   /opt/ruby-2.2/bin/thin:6:in `&amp;lt;main&amp;gt;&amp;#039;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;対応策:273ca993f084584514ef76dff312aa4b&#34;&gt;対応策&lt;/h2&gt;

&lt;p&gt;　プラグインのroutes.rbを正しく書き換えます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ more plugins/redmine_cors/config/routes.rb 
RedmineApp::Application.routes.draw do
  match &amp;#039;*path&amp;#039;, :to =&amp;gt; &amp;#039;cors#preflight&amp;#039;, via: :options
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　なお、書き換えた後に気が付いたのですが、Redmine CORSをRedmine3.0で動作させるためのプルリクエストが出てますね。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>asciidocをPDFに変換してみた（asciidoctor-pdf）</title>
      <link>http://aimless.jp/blog/archives/2641</link>
      <pubDate>Wed, 01 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2641</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://aimless.jp/blog/blog/archives/2506&#34;&gt;気軽にドキュメントを書く&lt;/a&gt;シリーズです。&lt;/p&gt;

&lt;p&gt;asciidocで書き、asciidoctor-pdfでさくっとPDFにするというソリューションがあるようなので試行錯誤を繰り返した結果、&lt;a href=&#34;https://gist.githubusercontent.com/kongou-ae/a3df7fb5aedf644acd72/raw/3227df201731519db0974813c1ff1f49dff19cc3/README.adoc&#34;&gt;この.adoc&lt;/a&gt;を&lt;a href=&#34;http://aimless.jp/blog/wp-content/uploads/2015/07/README.pdf&#34;&gt;このPDF&lt;/a&gt;に変換できるようになりました。&lt;/p&gt;

&lt;p&gt;使い方ではまった箇所をメモしておきます。&lt;/p&gt;

&lt;h2 id=&#34;インストール:0276447e54b8cc1adc3ebe7f7301ea42&#34;&gt;インストール&lt;/h2&gt;

&lt;p&gt;githubのREADMEに書いてある通り、gemでインストールするだけ。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ gem install --pre asciidoctor-pdf
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;デフォルトのテーマでpdfに変換する:0276447e54b8cc1adc3ebe7f7301ea42&#34;&gt;デフォルトのテーマでPDFに変換する&lt;/h2&gt;

&lt;p&gt;asciidoctor-pdfコマンドを利用します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ asciidoctor-pdf basic-example.adoc
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;自作テーマを利用してpdfに変換する:0276447e54b8cc1adc3ebe7f7301ea42&#34;&gt;自作テーマを利用してPDFに変換する&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/asciidoctor/asciidoctor-pdf/blob/master/docs/theming-guide.adoc&#34;&gt;Asciidoctor PDF Theming Guide&lt;/a&gt;に記載されている通り、自分なりのテーマを作ることができます。テーマを自作するにあたっては、&lt;a href=&#34;https://github.com/asciidoctor/asciidoctor-pdf/blob/master/data/themes/default-theme.yml&#34;&gt;デフォルトテーマ&lt;/a&gt;の記載内容が参考になります。&lt;/p&gt;

&lt;p&gt;今回は&lt;a href=&#34;https://gist.github.com/kongou-ae/46291f86c53d959271a7&#34;&gt;basic-theme.yml&lt;/a&gt;を作りました。ファイルはresources/themes配下に配置されています。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree
.
|-- build.sh
|-- README.adoc
|-- README.pdf
|-- README.pdfmarks
`-- resources
    |-- fonts
    |-- images
    `-- themes
        |-- basic-theme.yml
        `-- header-img-10mm.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;自作テーマを利用するためには、asciidoctor-pdfコマンドの-aオプションで、pdf-stylesdirとpdf-styleを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;asciidoctor-pdf -a pdf-stylesdir=/resources/themes -a pdf-style=basic README.adoc
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ページ番号を振る:0276447e54b8cc1adc3ebe7f7301ea42&#34;&gt;ページ番号を振る&lt;/h2&gt;

&lt;p&gt;ヘッダーとフッターにページ番号を振ることができます。今回は、.adocに:pagenums:を設定した上で、テーマファイルにページ番号の具体的なスタイルを記載します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ more README.adoc                                                                                   
= ほげほげサービス仕様書
ほげほげ株式会社 &amp;lt;doc.writer@example.jp&amp;gt;
v1.0, 2014-01-01
:toc:
:toc-title: 目次
:figure-caption: 図
:table-caption: 表
:toclevels: 2
:pagenums:
:sectnums:
:imagesdir: resources/images/


== はじめに 

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今回はフッターの真ん中にページ番号を表示してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;footer:
  font_size: $base_font_size_small
  font_color: $base_font_color
  border_color: dddddd
  border_width: 0.25
  height: 25mm
  padding: [3mm,0,0,0]
  valign: top
  recto_content:
    center: &amp;#039;{page-number} / {page-count}&amp;#039;
  verso_content:
    center: &amp;#039;{page-number} / {page-count}&amp;#039;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このようにフッターにページ番号が表示されます。今回はフッターにページ番号を付与しましたが、ヘッダーに付与することも可能です。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/07/asciidoctor_page_number.png&#34; alt=&#34;フッタ&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;ヘッダーやフッターに画像を追加する:0276447e54b8cc1adc3ebe7f7301ea42&#34;&gt;ヘッダーやフッターに画像を追加する&lt;/h2&gt;

&lt;p&gt;ヘッダーやフッターに画像を追加することが可能です。まずは。追加したい画像をテーマと同じディレクトリに配置します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree
.
|-- build.sh
|-- README.adoc
|-- README.pdf
|-- README.pdfmarks
`-- resources
    |-- fonts
    |-- images
    `-- themes
        |-- basic-theme.yml
        `-- header-img-10mm.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、以下の様に設定します。今回はrecto_content_rightに画像を表示します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;header:
  font_size: $base_font_size_small
  font_color: $base_font_color
  border_color: dddddd
  border_width: 0.25
  height: 25mm
  padding: [0,0,3mm,0]
  valign: bottom
  image_valign: 50
  recto_content:
    left: &amp;#039;{document-title}&amp;#039;
    right: image:header-img-10mm.png[width=&#34;75&#34;]
  verso_content:
    left: &amp;#039;{document-title}&amp;#039;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ヘッダの右に画像が表示されました。ただしverso_content_rightにはimageを指定していないので、右ページには画像が出ますが、左ページには画像が出ません。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/07/asciidoctor_header_image.png&#34; alt=&#34;ヘッダーに画像&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;フォントを指定する:0276447e54b8cc1adc3ebe7f7301ea42&#34;&gt;フォントを指定する&lt;/h2&gt;

&lt;p&gt;デフォルトでは以下3種類のフォントが利用可能です。これら以外のフォントを利用することも可能です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;NotoSerif&lt;/li&gt;
&lt;li&gt;Mplus1mn&lt;/li&gt;
&lt;li&gt;Mplus1pMultilingual&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Mplus1pMultilingual　にはboldがないので、migmix-1pを利用してみましょう。&lt;/p&gt;

&lt;p&gt;今回はresources/fonts配下にフォントを配置します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ tree                                                                                   
.
|-- build.sh
|-- README.adoc
|-- README.pdf
|-- README.pdfmarks
`-- resources
    |-- fonts
    |   `-- migmix-1p
    |       |-- ipag00303
    |       |   |-- IPA_Font_License_Agreement_v1.0.txt
    |       |   `-- Readme_ipag00303.txt
    |       |-- migmix-1p-bold.ttf
    |       |-- migmix-1p-regular.ttf
    |       `-- migmix-README.txt
    |-- images
    `-- themes
        |-- basic-theme.yml
        `-- header-img-10mm.png
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;テーマファイルでmigmixを使うことを宣言します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;font:
  catalog:
    migmix:
      normal: migmix-1p/migmix-1p-regular.ttf
      bold: migmix-1p/migmix-1p-bold.ttf
      italic: migmix-1p/migmix-1p-regular.ttf
      bold_italic: migmix-1p/migmix-1p-bold.ttf
  fallbacks:
    - migmix                                                                                                               
page:
  background_color: ffffff
  layout: portrait
  margin: [30mm, 30mm, 30mm, 30mm]
  size: A4
base:
  font_color: 000000
  font_family: migmix
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;asciidoctor-pdfコマンドの-aオプションでpdf-fontsdirを指定します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;asciidoctor-pdf -a pdf-stylesdir=/resources/themes -a pdf-style=basic -a pdf-fontsdir=/resources/fonts README.adoc
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;所感:0276447e54b8cc1adc3ebe7f7301ea42&#34;&gt;所感&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;PDFは綺麗に描画された。&lt;/li&gt;
&lt;li&gt;描画に至るまでの準備が簡単&lt;/li&gt;
&lt;li&gt;テーマのスタイルファイルは独自形式なので、CSSでの装飾と比べると自由度は狭い。

&lt;ul&gt;
&lt;li&gt;たとえば、現在の私の力では、テーブルの横幅を縮めることができない。[width=&amp;#8221;50&amp;#8243;]で表の横幅が50%になるはずなのだが、PDFに表示される表の横幅は100%になってしまいまう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;必要最低限に装飾したPDFを作る分にはもってこいかも&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>VPC FLow Logsを継続的にElasticSearchに投入する</title>
      <link>http://aimless.jp/blog/archives/2617</link>
      <pubDate>Sun, 14 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2617</guid>
      <description>

&lt;p&gt;VPC FLow Logsのリリース直後から、クラメソさんの「&lt;a href=&#34;http://dev.classmethod.jp/cloud/aws/vpc-flow-logs-visualized-kibana4/&#34;&gt;VPC Flow LogsをElasticsearch + Kibana4で可視化する&lt;/a&gt;」と同じことを考えていました。週末に試行錯誤した結果をアウトプットします。&lt;/p&gt;

&lt;h2 id=&#34;ログの取り方:879fe74068b1e39f8423ed492442144f&#34;&gt;ログの取り方&lt;/h2&gt;

&lt;p&gt;　AWS SDK for Ruby を利用してClodWatch Logsを取得する方法は以下の様になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# coding: utf-8

require &amp;#039;aws-sdk-core&amp;#039;

cloudwatchlogs = Aws::CloudWatchLogs::Client.new(region: region )

# cloudwatchlogs.get_log_eventsのオプションを定義
options = {
    log_group_name: log_group_name,
    log_stream_name: log_stream_name,
}

# ログを取得
resp = cloudwatchlogs.get_log_events(options)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　ただし、この方法でログを取得した場合、指定したlog_streamに格納されている大量のデータがレスポンスとして帰ってきます。デフォルトでは最大で1M Byte分のログが取得するようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/sdkforruby/api/Aws/CloudWatchLogs/Client.html#get_log_events-instance_method&#34;&gt;Class: Aws::CloudWatchLogs::Client&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;By default, this operation returns as much log events as can fit in a response size of 1MB, up to 10,000 log events.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　したがって、このコードを継続的に実行すると、最初から1M byte分のログを繰り返し取得してしまいます。これでは意味がありません。実行時には、前回実行分以降のログを取得してほしい。これを実現する方法が、&lt;code&gt;get_log_events&lt;/code&gt;の&lt;code&gt;next_token&lt;/code&gt;オプションです。&lt;/p&gt;

&lt;h2 id=&#34;増分ログの取り方:879fe74068b1e39f8423ed492442144f&#34;&gt;増分ログの取り方&lt;/h2&gt;

&lt;p&gt;　&lt;code&gt;get_log_events&lt;/code&gt;のレスポンスには&lt;code&gt;next_forward_token&lt;/code&gt;と&lt;code&gt;next_backward_token&lt;/code&gt;が含まれています。これらは取得結果の次のページの位置を示しています。より新しいログの位置は名前的に&lt;code&gt;next_forward_token&lt;/code&gt;が保持しているっぽいです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/sdkforruby/api/Aws/CloudWatchLogs/Client.html#get_log_events-instance_method&#34;&gt;Class: Aws::CloudWatchLogs::Client&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;resp.events #=&amp;gt; Array&lt;/p&gt;

&lt;p&gt;resp.events[0].timestamp #=&amp;gt; Integer&lt;/p&gt;

&lt;p&gt;resp.events[0].message #=&amp;gt; String&lt;/p&gt;

&lt;p&gt;resp.events[0].ingestion_time #=&amp;gt; Integer&lt;/p&gt;

&lt;p&gt;resp.next_forward_token #=&amp;gt; String&lt;/p&gt;

&lt;p&gt;resp.next_backward_token #=&amp;gt; String&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　そこで、このtokenを利用して&lt;code&gt;get_log_events&lt;/code&gt;を実行するように、スクリプトを変更します。tokenの値は、fluentdっぽくstateファイルを作り、そこに書き込んでおきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# coding: utf-8

require &amp;#039;aws-sdk-core&amp;#039;
require &amp;#039;fileutils&amp;#039;

region = &amp;#039;ap-northeast-1&amp;#039;
log_group_name = &amp;#039;VPCFLowLog&amp;#039;
log_stream_name = &amp;#039;eni-xxxxxxxx-all&amp;#039;
@state_file = Dir.pwd + &#34;/&#34; + log_group_name + &#34;.&#34; + log_stream_name + &#34;.state&#34;

# トークンをstateファイルに書き込む
def write_token(token)
    File.open(@state_file,&#34;w&#34;) do |file|
        file.puts(token)
    end
end

# トークンをstateファイルから読み込む
def read_token
    if File.exist?(@state_file) then
        return File.read(@state_file).chomp
    else
        return 
    end
end

cloudwatchlogs = Aws::CloudWatchLogs::Client.new(region: region )

# cloudwatchlogs.get_log_eventsのオプションを定義
options = {
    log_group_name: log_group_name,
    log_stream_name: log_stream_name,
}

# もしstateファイルから前回のtokenが取得できたら、そのtokenをオプションに追加
if read_token != nil  then
    options[:next_token] = read_token
end

# ログを取得
resp = cloudwatchlogs.get_log_events(options)

# 取得したログからtokenを保存
write_token(resp.next_forward_token)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;動作確認:879fe74068b1e39f8423ed492442144f&#34;&gt;動作確認&lt;/h2&gt;

&lt;p&gt;　ElasticSearchに投入済みのデータは以下の通りです。19:25:47までのログが格納されています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/06/001.png&#34; alt=&#34;投入済みデータ&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;　&lt;code&gt;next_token&lt;/code&gt;をつけて&lt;code&gt;get_log_events&lt;/code&gt;したデータをElasticSearchに投入します。投入時のログは以下の通りです。19:28:40のデータ以降がElasticSearchに投入されていることがわかります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-06-14 19:38:36 +0900: &amp;gt; {&#34;@timestamp&#34;:&#34;2015-06-14 19:28:40&#34;,&#34;version&#34;:&#34;2&#34;,&#34;account-id&#34;:&#34;250369693989&#34;,&#34;interface-id&#34;:&#34;eni-f5a92c83&#34;,&#34;srcaddr&#34;:&#34;157.7.235.92&#34;,&#34;dstaddr&#34;:&#34;10.175.10.97&#34;,&#34;srcport&#34;:&#34;123&#34;,&#34;dstport&#34;:&#34;123&#34;,&#34;protocol&#34;:&#34;17&#34;,&#34;packets&#34;:&#34;1&#34;,&#34;bytes&#34;:&#34;76&#34;,&#34;start&#34;:&#34;1434277720&#34;,&#34;end&#34;:&#34;1434277760&#34;,&#34;action&#34;:&#34;ACCEPT&#34;,&#34;log-status&#34;:&#34;OK&#34;}
2015-06-14 19:38:36 +0900: &amp;lt; {&#34;_index&#34;:&#34;aws&#34;,&#34;_type&#34;:&#34;vpcflowlog&#34;,&#34;_id&#34;:&#34;AU3xpkmyyQj6bWWoL4TA&#34;,&#34;_version&#34;:1,&#34;created&#34;:true}
2015-06-14 19:38:36 +0900: POST http://localhost:9200/aws/vpcflowlog [status:201, request:0.004s, query:n/a]
2015-06-14 19:38:36 +0900: &amp;gt; {&#34;@timestamp&#34;:&#34;2015-06-14 19:28:40&#34;,&#34;version&#34;:&#34;2&#34;,&#34;account-id&#34;:&#34;250369693989&#34;,&#34;interface-id&#34;:&#34;eni-f5a92c83&#34;,&#34;srcaddr&#34;:&#34;10.175.10.97&#34;,&#34;dstaddr&#34;:&#34;157.7.235.92&#34;,&#34;srcport&#34;:&#34;123&#34;,&#34;dstport&#34;:&#34;123&#34;,&#34;protocol&#34;:&#34;17&#34;,&#34;packets&#34;:&#34;1&#34;,&#34;bytes&#34;:&#34;76&#34;,&#34;start&#34;:&#34;1434277720&#34;,&#34;end&#34;:&#34;1434277760&#34;,&#34;action&#34;:&#34;ACCEPT&#34;,&#34;log-status&#34;:&#34;OK&#34;}
2015-06-14 19:38:36 +0900: &amp;lt; {&#34;_index&#34;:&#34;aws&#34;,&#34;_type&#34;:&#34;vpcflowlog&#34;,&#34;_id&#34;:&#34;AU3xpkm4yQj6bWWoL4TB&#34;,&#34;_version&#34;:1,&#34;created&#34;:true}
2015-06-14 19:38:36 +0900: POST http://localhost:9200/aws/vpcflowlog [status:201, request:0.003s, query:n/a]
2015-06-14 19:38:36 +0900: &amp;gt; {&#34;@timestamp&#34;:&#34;2015-06-14 19:28:40&#34;,&#34;version&#34;:&#34;2&#34;,&#34;account-id&#34;:&#34;250369693989&#34;,&#34;interface-id&#34;:&#34;eni-f5a92c83&#34;,&#34;srcaddr&#34;:&#34;162.255.180.213&#34;,&#34;dstaddr&#34;:&#34;10.175.10.97&#34;,&#34;srcport&#34;:&#34;1982&#34;,&#34;dstport&#34;:&#34;445&#34;,&#34;protocol&#34;:&#34;6&#34;,&#34;packets&#34;:&#34;2&#34;,&#34;bytes&#34;:&#34;96&#34;,&#34;start&#34;:&#34;1434277720&#34;,&#34;end&#34;:&#34;1434277760&#34;,&#34;action&#34;:&#34;REJECT&#34;,&#34;log-status&#34;:&#34;OK&#34;}
2015-06-14 19:38:36 +0900: &amp;lt; {&#34;_index&#34;:&#34;aws&#34;,&#34;_type&#34;:&#34;vpcflowlog&#34;,&#34;_id&#34;:&#34;AU3xpkm9yQj6bWWoL4TC&#34;,&#34;_version&#34;:1,&#34;created&#34;:true}
2015-06-14 19:38:36 +0900: POST http://localhost:9200/aws/vpcflowlog [status:201, request:0.003s, query:n/a]
（中略）
2015-06-14 19:38:36 +0900: &amp;gt; {&#34;@timestamp&#34;:&#34;2015-06-14 19:35:22&#34;,&#34;version&#34;:&#34;2&#34;,&#34;account-id&#34;:&#34;250369693989&#34;,&#34;interface-id&#34;:&#34;eni-f5a92c83&#34;,&#34;srcaddr&#34;:&#34;10.175.10.97&#34;,&#34;dstaddr&#34;:&#34;46.17.98.184&#34;,&#34;srcport&#34;:&#34;22&#34;,&#34;dstport&#34;:&#34;27530&#34;,&#34;protocol&#34;:&#34;6&#34;,&#34;packets&#34;:&#34;1&#34;,&#34;bytes&#34;:&#34;48&#34;,&#34;start&#34;:&#34;1434278122&#34;,&#34;end&#34;:&#34;1434278181&#34;,&#34;action&#34;:&#34;ACCEPT&#34;,&#34;log-status&#34;:&#34;OK&#34;}
2015-06-14 19:38:36 +0900: &amp;lt; {&#34;_index&#34;:&#34;aws&#34;,&#34;_type&#34;:&#34;vpcflowlog&#34;,&#34;_id&#34;:&#34;AU3xpkoQyQj6bWWoL4TY&#34;,&#34;_version&#34;:1,&#34;created&#34;:true}
2015-06-14 19:38:36 +0900: POST http://localhost:9200/aws/vpcflowlog [status:201, request:0.002s, query:n/a]
2015-06-14 19:38:36 +0900: &amp;gt; {&#34;@timestamp&#34;:&#34;2015-06-14 19:36:55&#34;,&#34;version&#34;:&#34;2&#34;,&#34;account-id&#34;:&#34;250369693989&#34;,&#34;interface-id&#34;:&#34;eni-f5a92c83&#34;,&#34;srcaddr&#34;:&#34;199.203.59.117&#34;,&#34;dstaddr&#34;:&#34;10.175.10.97&#34;,&#34;srcport&#34;:&#34;26600&#34;,&#34;dstport&#34;:&#34;80&#34;,&#34;protocol&#34;:&#34;6&#34;,&#34;packets&#34;:&#34;1&#34;,&#34;bytes&#34;:&#34;48&#34;,&#34;start&#34;:&#34;1434278215&#34;,&#34;end&#34;:&#34;1434278241&#34;,&#34;action&#34;:&#34;REJECT&#34;,&#34;log-status&#34;:&#34;OK&#34;}
2015-06-14 19:38:36 +0900: &amp;lt; {&#34;_index&#34;:&#34;aws&#34;,&#34;_type&#34;:&#34;vpcflowlog&#34;,&#34;_id&#34;:&#34;AU3xpkoTyQj6bWWoL4TZ&#34;,&#34;_version&#34;:1,&#34;created&#34;:true}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　投入後のデータ一覧は以下の通りです。19:25:47以前のログが重複登録されることなく、19:25:47以降のログが増えました！！！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/06/002.png&#34; alt=&#34;投入済みデータ&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;　それっぽく動いたスクリプトは以下の通りです。cronで回してみてみようと思います。&lt;/p&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# coding: utf-8

require &#34;json&#34;
require &amp;#039;aws-sdk-core&amp;#039;
require &amp;#039;elasticsearch&amp;#039;
require &amp;#039;fileutils&amp;#039;

region = &amp;#039;ap-northeast-1&amp;#039;
log_group_name = &amp;#039;VPCFLowLog&amp;#039;
log_stream_name = &amp;#039;eni-xxxxxxxx-all&amp;#039;
@state_file = Dir.pwd + &#34;/&#34; + log_group_name + &#34;.&#34; + log_stream_name + &#34;.state&#34;

# トークンをstateファイルに書き込む
def write_token(token)
    File.open(@state_file,&#34;w&#34;) do |file|
        file.puts(token)
    end
end

# トークンをstateファイルから読み込む
def read_token
    if File.exist?(@state_file) then
        return File.read(@state_file).chomp
    else
        return 
    end
end

cloudwatchlogs = Aws::CloudWatchLogs::Client.new(region: region )

# cloudwatchlogs.get_log_eventsのオプションを定義
options = {
    log_group_name: log_group_name,
    log_stream_name: log_stream_name,
}

# もしstateファイルから前回のtokenが取得できたら、そのtokenをオプションに追加
if read_token != nil  then
    options[:next_token] = read_token
end

# ログを取得
resp = cloudwatchlogs.get_log_events(options)

# 取得したログからtokenを保存
write_token(resp.next_forward_token)

hash = {}
message_elements = Array.new()

message_field = [
    &#34;version&#34;,
    &#34;account-id&#34;,
    &#34;interface-id&#34;,
    &#34;srcaddr&#34;,
    &#34;dstaddr&#34;,
    &#34;srcport&#34;,
    &#34;dstport&#34;,
    &#34;protocol&#34;,
    &#34;packets&#34;,
    &#34;bytes&#34;,
    &#34;start&#34;,
    &#34;end&#34;,
    &#34;action&#34;,
    &#34;log-status&#34;]

resp.events.each {|event|

    hash[&#34;@timestamp&#34;] = Time.at(event.timestamp/1000.0).strftime(&amp;#039;%Y-%m-%d %H:%M:%S&amp;#039;)
    message_elements = event.message.split(&#34; &#34;)
    message_elements.each.with_index(0)  {|element,i|
        hash[message_field[i]] = element
    }

    # BytesとPacketsをInteger型にすると、NODATAの時の-が型エラーになるので、捨てる
    if hash[&#34;log-status&#34;] != &#34;NODATA&#34; then
        client = Elasticsearch::Client.new(hosts: &#34;localhost:9200&#34;,log: true)
        client.index(index:&#34;aws&#34;, type:&#34;vpcflowlog&#34;, body:hash.to_json)
    end
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>PrometheusでAmazon Linuxのメトリクスを収集する</title>
      <link>http://aimless.jp/blog/archives/2595</link>
      <pubDate>Sun, 10 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2595</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://aimless.jp/blog/blog/archives/2586&#34;&gt;Amazon LinuxでPrometheusを動かしてみた&lt;/a&gt;で動いたPrometheusを利用して、サーバのメトリクスを収集します。今回はPrometheusが稼働しているAmazon Linuxのメトリクスを収集します。&lt;/p&gt;

&lt;h2 id=&#34;node-exporterを稼働させる:e67d1193b4ff96687e3431437834ddb9&#34;&gt;node_exporterを稼働させる&lt;/h2&gt;

&lt;p&gt;　メトリクスを収集したいサーバでnode_exporterというバイナリを起動します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum install git hg gcc golang
git clone https://github.com/prometheus/node_exporter.git
make
./node_exporter &amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　node_exporterは、Prometheusサーバが読み取れるデータを生成し9100ポートで公開してくれます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ec2-user@ip-10-175-10-126 ~]$  wget http://localhost:9100/metrics
[ec2-user@ip-10-175-10-126 ~]$ more metrics 
# HELP go_gc_duration_seconds A summary of the GC invocation durations.
# TYPE go_gc_duration_seconds summary
go_gc_duration_seconds{quantile=&#34;0&#34;} 8.5685e-05
go_gc_duration_seconds{quantile=&#34;0.25&#34;} 0.0006615610000000001
go_gc_duration_seconds{quantile=&#34;0.5&#34;} 0.00068378
go_gc_duration_seconds{quantile=&#34;0.75&#34;} 0.000708493
go_gc_duration_seconds{quantile=&#34;1&#34;} 0.017944932
go_gc_duration_seconds_sum 0.155032352
go_gc_duration_seconds_count 205
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　なお、node_exporterはWindowsをサポートしないようです。（&lt;a href=&#34;https://github.com/prometheus/node_exporter/issues/65&#34;&gt;Windows support&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;　node_exporterと同じように、定期的に自サーバのメトリクスを取得し、ファイルに書き込み、httpで公開できる仕組みを作れば、windowsでもメトリクスを収集できる気がします。&lt;/p&gt;

&lt;h2 id=&#34;prometheusにnodeを登録する:e67d1193b4ff96687e3431437834ddb9&#34;&gt;Prometheusにnodeを登録する&lt;/h2&gt;

&lt;p&gt;　Prometheusサーバに、node_exporterが生成するデータを登録します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[ec2-user@ip-10-175-10-126 ~]$ cat prometheus.conf  
（中略）
job: {
  name: &#34;node&#34;
  scrape_interval: &#34;5s&#34;
  target_group: {
    target: &#34;http://localhost:9100/metrics&#34;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;prometheusでメトリクスを確認する:e67d1193b4ff96687e3431437834ddb9&#34;&gt;Prometheusでメトリクスを確認する&lt;/h2&gt;

&lt;p&gt;　Prometheusサーバを再起動すると、コンソールにNodeが追加され、メトリクスを収集している対象の一覧が表示されます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/05/primetheus_node_summary.png&#34; alt=&#34;primetheus_node_summary&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;　対象のノードをクリックすると、CPUとメモリ、ディスクのグラフが描画されています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/05/prometheus_node_detail.png&#34; alt=&#34;prometheus_node_detail&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;　Graphタブを利用することで、取得したメトリクスのグラフを描画することが可能です。データの抽出は&lt;a href=&#34;http://prometheus.io/docs/querying/basics/#querying-prometheus&#34;&gt;QUERY LANGUAGE&lt;/a&gt;を利用する必要があります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/05/prometheus_node_metric_graph.png&#34; alt=&#34;prometheus_node_metric_graph&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Amazon LinuxでPrometheusを動かしてみた</title>
      <link>http://aimless.jp/blog/archives/2586</link>
      <pubDate>Sat, 09 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2586</guid>
      <description>&lt;p&gt;Prometheusを試してみようと思いインストール方法を調べた結果、バイナリファイルが公開されていることがわかりました。バイナリファイルを利用すると、さくっと動いたのでメモしておきます。必要な手順は以下の通りです。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;tarballのダウンロードと解凍&lt;/li&gt;
&lt;li&gt;prometheus.confの作成（&lt;a href=&#34;http://prometheus.io/docs/introduction/getting_started/#configuring-prometheus-to-monitor-itself&#34;&gt;GETTING STARTEDの内容をままコピペ&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;prometheusの起動&lt;/li&gt;
&lt;li&gt;HTTPで9090ポートにアクセス&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code&gt;[ec2-user@ip-10-175-10-126 ~]$ wget https://github.com/prometheus/prometheus/releases/download/0.13.2/prometheus-0.13.2.linux-amd64.tar.gz
--2015-05-09 12:07:12--  https://github.com/prometheus/prometheus/releases/download/0.13.2/prometheus-0.13.2.linux-amd64.tar.gz
Resolving github.com (github.com)... 192.30.252.131
Connecting to github.com (github.com)|192.30.252.131|:443... connected.
HTTP request sent, awaiting response... 302 Found
Location: https://s3.amazonaws.com/github-cloud/releases/6838921/b318dbf0-f3e7-11e4-8be7-d3716d1f32e5.gz?response-content-disposition=attachment%3B%20filename%3Dprometheus-0.13.2.linux-amd64.tar.gz&amp;response-content-type=application/octet-stream&amp;AWSAccessKeyId=AKIAISTNZFOVBIJMK3TQ&amp;Expires=1431173292&amp;Signature=J5eC%2F4n8UDnReRDLitzGezZLj88%3D [following]
--2015-05-09 12:07:13--  https://s3.amazonaws.com/github-cloud/releases/6838921/b318dbf0-f3e7-11e4-8be7-d3716d1f32e5.gz?response-content-disposition=attachment%3B%20filename%3Dprometheus-0.13.2.linux-amd64.tar.gz&amp;response-content-type=application/octet-stream&amp;AWSAccessKeyId=AKIAISTNZFOVBIJMK3TQ&amp;Expires=1431173292&amp;Signature=J5eC%2F4n8UDnReRDLitzGezZLj88%3D
Resolving s3.amazonaws.com (s3.amazonaws.com)... 54.231.244.8
Connecting to s3.amazonaws.com (s3.amazonaws.com)|54.231.244.8|:443... connected.
HTTP request sent, awaiting response... 200 OK
Length: 6796769 (6.5M) [application/octet-stream]
Saving to: ‘prometheus-0.13.2.linux-amd64.tar.gz’

prometheus-0.13.2.linux-am 100%[==========================================&amp;gt;]   6.48M  1.89MB/s   in 3.4s   

2015-05-09 12:07:17 (1.89 MB/s) - ‘prometheus-0.13.2.linux-amd64.tar.gz’ saved [6796769/6796769]

[ec2-user@ip-10-175-10-126 ~]$ tar xzvf prometheus-0.13.2.linux-amd64.tar.gz 
prometheus
tools/rule_checker/rule_checker
consoles/
consoles/haproxy.html
consoles/cassandra.html
consoles/haproxy-frontend.html
consoles/index.html.example
consoles/node-overview.html
consoles/federation_template_example.txt
consoles/aws_elb.html
consoles/aws_redshift-cluster.html
consoles/node-cpu.html
consoles/index.html
consoles/node-disk.html
consoles/haproxy-backends.html
consoles/aws_redshift.html
consoles/cloudwatch.html
consoles/aws_elasticache.html
consoles/haproxy-backend.html
consoles/node.html
consoles/haproxy-frontends.html
console_libraries/
console_libraries/prom.lib
console_libraries/menu.lib
[ec2-user@ip-10-175-10-126 ~]$ ls
console_libraries  consoles  prometheus  prometheus-0.13.2.linux-amd64.tar.gz  tools

[ec2-user@ip-10-175-10-126 ~]$ touch prometheus.conf                                                        
[ec2-user@ip-10-175-10-126 ~]$ vim prometheus.conf 
[ec2-user@ip-10-175-10-126 ~]$ ./prometheus 
prometheus, version 0.13.2 (branch: HEAD, revision: f4d90a1)
  build user:       fish@localhost
  build date:       20150506-12:01:47
  go version:       1.4.2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/05/Prometheus_GUI.png&#34; alt=&#34;GUI&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Let’s Chatでhubotを動かす</title>
      <link>http://aimless.jp/blog/archives/2570</link>
      <pubDate>Sat, 02 May 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2570</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://sdelements.github.io/lets-chat/&#34;&gt;Let&amp;#8217;s Chat&lt;/a&gt;でhubotを動かしてみました。&lt;/p&gt;

&lt;h2 id=&#34;let-8217-s-chatのインストール:cfa74896d771b319eb38f92c098ab1f2&#34;&gt;Let&amp;#8217;s Chatのインストール&lt;/h2&gt;

&lt;p&gt;　nodejsとpythonはインストール済みなので、mongodbのみyumでインストールします。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo yum install mongodb
sudo yum install mongodb-server.x86_64
sudo systemctl start mongod.service
git clone https://github.com/sdelements/lets-chat.git
cd lets-chat
npm install
npm start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　デフォルトだと5000番でリッスンします。FQDNやポート番号を含む各種パラメータは&lt;code&gt;settings.yml&lt;/code&gt;で変更可能です。今回は、Let&amp;#8217;s Chatはデフォルト設定のままとし、前段のnginxでバーチャルホスト+80番のアクセスを受けて、Let&amp;#8217;s Chatの5000番にProxyPassしています。&lt;/p&gt;

&lt;h2 id=&#34;hubot用アカウントの作成:cfa74896d771b319eb38f92c098ab1f2&#34;&gt;hubot用アカウントの作成&lt;/h2&gt;

&lt;p&gt;　Let&amp;#8217;s Chatにhubot用のアカウントを作成します。また作成したアカウントのAuth Tokenを取得します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/05/SnapCrab_NoName_2015-5-2_23-16-54_No-00.png&#34; alt=&#34;Token&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;hubotのインストール:cfa74896d771b319eb38f92c098ab1f2&#34;&gt;hubotのインストール&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;sudo  npm install -g yo generator-hubot
mkdir myhubot
cd myhubot
yo hubot
npm install hubot-lets-chat --save
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hubot起動スクリプトの作成:cfa74896d771b319eb38f92c098ab1f2&#34;&gt;hubot起動スクリプトの作成&lt;/h2&gt;

&lt;p&gt;　&lt;code&gt;HUBOT_LCB_TOKEN&lt;/code&gt;の項目に、Let&amp;#8217;s Chat上で取得したhubotアカウントのAuth Tokenを記載します。また&lt;code&gt;HUBOT_LCB_ROOMS&lt;/code&gt;にはhubotを常駐させたいRoomの識別子（URLに含まれる値）を入力します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;myhubot]$ cat run_hubot.sh
export HUBOT_LCB_TOKEN=TOKEN_OF_YOUR_HUBOT_ACCOUNT
export HUBOT_LCB_ROOMS=553db2dcf62762863672ea19
bin/hubot -a lets-chat
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;hubotの起動-動作確認:cfa74896d771b319eb38f92c098ab1f2&#34;&gt;hubotの起動＋動作確認&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;myhubot]$ ./run_hubot.sh                                 
connected
[Sun May 03 2015 00:01:55 GMT+0900 (JST)] ERROR hubot-heroku-alive included, but missing HUBOT_HEROKU_KEEPALIVE_URL. `heroku config:set HUBOT_HEROKU_KEEPALIVE_URL=$(heroku apps:info -s  | grep web_url | cut -d= -f2)`
[Sun May 03 2015 00:01:55 GMT+0900 (JST)] INFO Using default redis on localhost:6379
Joined test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　&lt;code&gt;test&lt;/code&gt;というルームにhubotがログインしました。hubotを停止すると退室します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/05/SnapCrab_NoName_2015-5-2_23-11-30_No-00.png&#34; alt=&#34;add room&#34; /&gt;
&lt;/p&gt;

&lt;p&gt;@つきでhubotに&lt;code&gt;ping&lt;/code&gt;や&lt;code&gt;date&lt;/code&gt;すると、ちゃんと答えます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/05/SnapCrab_NoName_2015-5-2_23-12-0_No-00.png&#34; alt=&#34;hubot response&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>aws-sdk-goでELB配下のインスタンスを取得する</title>
      <link>http://aimless.jp/blog/archives/2546</link>
      <pubDate>Sat, 11 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2546</guid>
      <description>&lt;p&gt;諸事情によりAWS製ツールをインストールできないWindows端末でAWSのAPIを叩く必要があり、手法を検討しました。あーだこーだと悩んだ結果、別の端末で作成したバイナリファイルを実行することを閃きました。こんな時のためのaws-sdk-goです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &#34;fmt&#34;
    &#34;github.com/awslabs/aws-sdk-go/aws&#34;
    &#34;github.com/awslabs/aws-sdk-go/service/elb&#34;
    &#34;sort&#34;
    &#34;strings&#34;
)

func main() {
    accessKey := &#34;YOUR_ACCESS_KEY&#34;
    secretKey := &#34;YOUR_AECRET_KEY&#34;
    region := &#34;ap-northeast-1&#34;
    elbName := &#34;YOUR_ELB_NAME&#34;
    var inserviceInstances []string

    cred := aws.DetectCreds(accessKey, secretKey, &#34;&#34;)
    elbSvc := elb.New(&amp;aws.Config{Credentials: cred, Region: region})

    param := &amp;elb.DescribeInstanceHealthInput{
        LoadBalancerName: aws.String(elbName),
    }

    res, err := elbSvc.DescribeInstanceHealth(param)

    if err != nil {
        panic(err)
    }

    for i := range res.InstanceStates {
        result := *res.InstanceStates[i].InstanceID + &#34;:&#34; + *res.InstanceStates[i].State
        inserviceInstances = append(inserviceInstances, result)
    }

    sort.Strings(inserviceInstances)
    fmt.Print(strings.Join(inserviceInstances, &#34;,&#34;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　このスクリプトを実行すると、対象ELB配下のインスタンスとその状態が表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;go run main.go
i-xxxxxxxx:OutOfService,i-xxxxxxxx:OutOfService
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　コンパイルしたバイナリファイルを実行しても同じ結果になります。このバイナリを問題のWindows端末で実行すれば問題は解決です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;go build main.go

&amp;gt;main.exe
i-xxxxxxxx:OutOfService,i-xxxxxxxx:OutOfService
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>気軽にドキュメントを書くための試行錯誤</title>
      <link>http://aimless.jp/blog/archives/2506</link>
      <pubDate>Sun, 05 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2506</guid>
      <description>

&lt;p&gt;これまで、Wordの使い方を覚えた方が早いのは理解しつつ、設計書や仕様書といったドキュメントを気軽に書く方法を模索してきました。&lt;/p&gt;

&lt;h2 id=&#34;これまでの取り組み:955fa4efa5135950a9b3b93648703bd0&#34;&gt;これまでの取り組み&lt;/h2&gt;

&lt;h3 id=&#34;rest-rst2pdf:955fa4efa5135950a9b3b93648703bd0&#34;&gt;reST + rst2pdf&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;方針

&lt;ul&gt;
&lt;li&gt;reSTとrst2pdfを使ってドキュメントの内容と見た目を分離。&lt;/li&gt;
&lt;li&gt;便利ツールの稼働環境をdockerでコンテナにすることで、会社のWindows上での動作を実現。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;結果

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://aimless.jp/blog/blog/archives/2067&#34;&gt;気軽にドキュメントを書く（Sphinx + rst2pdf + LiveReload + docker）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PDF作成ツールのrst2pdfの情報が少なく、見た目を拡張することに限界を感じた。&lt;/li&gt;
&lt;li&gt;reSTよりもMarkdownを使いたくなった。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;markdown-pandoc:955fa4efa5135950a9b3b93648703bd0&#34;&gt;markdown + pandoc&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;方針

&lt;ul&gt;
&lt;li&gt;コンテナの利用は継続。&lt;/li&gt;
&lt;li&gt;PDF作成ツールとして、rst2pdfの代わりにpandocを利用。これによりMarkdownを利用可能に。&lt;/li&gt;
&lt;li&gt;rst2pdfでは実現できなかった見た目の拡張性をtexで頑張ることにした。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;結果

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kongou-ae/doc-man&#34;&gt;doc-man&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;pandocで日本語pdfを生成するためには日本語Latexの環境を用意する必要がある。これが気軽ではない。&lt;/li&gt;
&lt;li&gt;一からtexの作法を学習するコストが高すぎる。&lt;/li&gt;
&lt;li&gt;会社のマシンがSSDになりディスク容量が激減。ローカルに執筆環境のコンテナで持つことが厳しくなってきた。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;atom-pdf印刷:955fa4efa5135950a9b3b93648703bd0&#34;&gt;Atom + PDF印刷&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;方針

&lt;ul&gt;
&lt;li&gt;コンテナをやめる。&lt;/li&gt;
&lt;li&gt;見た目はCSSで頑張る。さようならtex。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;結果

&lt;ul&gt;
&lt;li&gt;Atomを使って議事メモをmarkdownで書き、Markdown Previewで確認、そのままHTMLに保存してPDFとして印刷。&lt;/li&gt;
&lt;li&gt;議事メモ等の気軽な文章を気軽に作成する事には向くが、壮大な文章を気軽に書くことに不向き。&lt;/li&gt;
&lt;li&gt;表紙や目次などが含まれるちゃんとしたドキュメントの作成に向かない。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;現在の取り組み:955fa4efa5135950a9b3b93648703bd0&#34;&gt;現在の取り組み&lt;/h2&gt;

&lt;p&gt;　上記の紆余曲折の結果、以下の形で試行錯誤を継続中です。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;方針

&lt;ul&gt;
&lt;li&gt;壮大な文章（設計書や仕様書）を気軽に作れる環境を目指す&lt;/li&gt;
&lt;li&gt;元ネタとなるプレーンテキストはMarkdownで書く。&lt;/li&gt;
&lt;li&gt;PDFの見た目は、CSSで頑張る。CSSで出来ない装飾はあきらめる。過剰な装飾はいらない。&lt;/li&gt;
&lt;li&gt;執筆環境をローカルのコンテナ上で動かすのをやめる。ローカルではテキストを書くだけ、管理やビルドはリモートのリポジトリに任せる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;進捗

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kongou-ae/md-kumihan&#34;&gt;md-kumihan&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://raw.githubusercontent.com/kongou-ae/md-kumihan/master/src/test.md&#34;&gt;このMarkdown&lt;/a&gt;が、コマンド一つで&lt;a href=&#34;https://github.com/kongou-ae/md-kumihan/blob/master/pdf/test.pdf&#34;&gt;このPDF&lt;/a&gt;になります。&lt;/li&gt;
&lt;li&gt;md-kumihanをGialabのリポジトリ上に配置し、ローカルでMarkdownを編集してPushすると、gitlab上のgit-hookやCIツールでPDFを自動ビルド、さらにリポジトリのwikiページにpdfへのリンクを作成とかもできます。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ドキュメントを中心とした継続的な運用改善:955fa4efa5135950a9b3b93648703bd0&#34;&gt;ドキュメントを中心とした継続的な運用改善&lt;/h2&gt;

&lt;p&gt;　現在の会社では、運用チームのリーダとして継続的な運用の改善を生業としています。ちゃんとやれているかは、かなり疑問ですが。。&lt;/p&gt;

&lt;p&gt;　運用の仕組みはドキュメントにする必要があります。ですが、その時間は限られています。運用の仕組みは継続的に改善する必要があり、改善の結果はドキュメントに反映させる必要があります。ですが、その時間も限られています。&lt;/p&gt;

&lt;p&gt;　限られた時間の中で効率よくドキュメントを作成し、改定し続けるにはどうすればいいか。自分の中の一つの仮説が「気軽にドキュメントを書く」と「ドキュメントを中心とした運用改善」です。&lt;/p&gt;

&lt;p&gt;　時間がない中でまとまった文章を書くためには気軽である必要があります。限られた時間は文章の内容を作成することに注力し、見た目はツールにお任せする事が望ましい。これが「気軽にドキュメントを書く」という考え方です。&lt;/p&gt;

&lt;p&gt;　運用の仕組み＝ドキュメントですから、運用の問題点はドキュメントの問題、運用改善のゴールはドキュメントの改定です。運用の問題点は、随時ドキュメントのIssueとして起票し、対応方法を検討し実践していく。問題点の改善が完了したら、改善点を反映させるためのWIP Marge Requestを作り、ドキュメントの改定作業を実施する。運用改善のタスクが、対応するドキュメントのリポジトリを中心にして回っていく。これが「ドキュメントを中心とした運用改善」です。&lt;/p&gt;

&lt;p&gt;　こんな世界も悪くないんじゃないかなと考え、仮説を検証中です。「気軽にドキュメントを書く」と「ドキュメントを中心とした運用改善」を実現するためのmd-kumihanというツールはできたので、次は自分のチームで勝手に実践だ。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terraformでセキュリティグループを管理する</title>
      <link>http://aimless.jp/blog/archives/2481</link>
      <pubDate>Sun, 22 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2481</guid>
      <description>

&lt;p&gt;Terraformによるセキュリティグループ管理に関するメモ。&lt;/p&gt;

&lt;p&gt;　Terraformのバージョンアップにより、タグ付けやegressのルールが使えるようになったので、マネジメントコンソールと同じ事ができるようになっています。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;version&lt;/th&gt;
&lt;th&gt;IMPROVEMENTS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0.3.7 (February 19, 2015)&lt;/td&gt;
&lt;td&gt;provider/aws: Security group support egress rules. [GH-856]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0.3.1 (October 21, 2014)&lt;/td&gt;
&lt;td&gt;providers/aws: Support tags for security groups.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;ファイル構成:29a47d36f0cb88ad8f2feca5cd4e2d83&#34;&gt;ファイル構成&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ ls                                               
var.tf　　  　terraform.tfvars        web-sg.tf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　tfファイルで利用する変数を定義するためのファイル&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  cat var.tf                                      
variable &#34;access_key&#34; {}
variable &#34;secret_key&#34; {}
variable &#34;region&#34; {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　tfファイルで利用する変数に値を代入するためのファイル&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat terraform.tfvars 
#-------------------------------------$
# credential$
#-------------------------------------$

access_key = &#34;YOUR_ACCESS_KEY&#34;
secret_key = &#34;YOUR_SECRET_KEY&#34;

#-------------------------------------
# region
#-------------------------------------
#
region = &#34;ap-northeast-1&#34;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　実際の処理を書いたファイル。WEBサーバ向けにHTTPを全許可するセキュリティグループを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat web-sg.tf 
provider &#34;aws&#34; {
    access_key = &#34;${var.access_key}&#34;
    secret_key = &#34;${var.secret_key}&#34;
    region = &#34;${var.region}&#34;
}

resource &#34;aws_security_group&#34; &#34;web-server&#34; {
  name = &#34;web-server-sg&#34;
  description = &#34;Allow traffic of webserver&#34;

  ingress {
      from_port = 80 
      to_port = 80
      protocol = &#34;tcp&#34;
      cidr_blocks = [&#34;0.0.0.0/0&#34;]
  }
  vpc_id = &#34;vpc-d01806b2&#34;
  tags {
    Name = &#34;web-server&#34;
    Made = &#34;terraform&#34;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;セキュリティグループの作成:29a47d36f0cb88ad8f2feca5cd4e2d83&#34;&gt;セキュリティグループの作成&lt;/h2&gt;

&lt;p&gt;まずは&lt;code&gt;terraform plan&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ terraform plan
Refreshing Terraform state prior to plan...


The Terraform execution plan has been generated and is shown below.
Resources are shown in alphabetical order for quick scanning. Green resources
will be created (or destroyed and then created if an existing resource
exists), yellow resources are being changed in-place, and red resources
will be destroyed.

Note: You didn&amp;#039;t specify an &#34;-out&#34; parameter to save this plan, so when
&#34;apply&#34; is called, Terraform can&amp;#039;t guarantee this is what will execute.

+ aws_security_group.web-server
    description:                          &#34;&#34; =&amp;gt; &#34;Allow traffic of webserver&#34;
    egress.#:                             &#34;&#34; =&amp;gt; &#34;&amp;lt;computed&amp;gt;&#34;
    ingress.#:                            &#34;&#34; =&amp;gt; &#34;1&#34;
    ingress.2603706321.cidr_blocks.#:     &#34;&#34; =&amp;gt; &#34;1&#34;
    ingress.2603706321.cidr_blocks.0:     &#34;&#34; =&amp;gt; &#34;0.0.0.0/0&#34;
    ingress.2603706321.from_port:         &#34;&#34; =&amp;gt; &#34;80&#34;
    ingress.2603706321.protocol:          &#34;&#34; =&amp;gt; &#34;tcp&#34;
    ingress.2603706321.security_groups.#: &#34;&#34; =&amp;gt; &#34;0&#34;
    ingress.2603706321.self:              &#34;&#34; =&amp;gt; &#34;0&#34;
    ingress.2603706321.to_port:           &#34;&#34; =&amp;gt; &#34;80&#34;
    name:                                 &#34;&#34; =&amp;gt; &#34;web-server-sg&#34;
    owner_id:                             &#34;&#34; =&amp;gt; &#34;&amp;lt;computed&amp;gt;&#34;
    tags.#:                               &#34;&#34; =&amp;gt; &#34;2&#34;
    tags.Made:                            &#34;&#34; =&amp;gt; &#34;terraform&#34;
    tags.Name:                            &#34;&#34; =&amp;gt; &#34;web-server&#34;
    vpc_id:                               &#34;&#34; =&amp;gt; &#34;vpc-d01806b2&#34;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　問題なさそうなので&lt;code&gt;terraform apply&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ terraform apply
aws_security_group.web-server: Creating...
  description:                          &#34;&#34; =&amp;gt; &#34;Allow traffic of webserver&#34;
  egress.#:                             &#34;&#34; =&amp;gt; &#34;&amp;lt;computed&amp;gt;&#34;
  ingress.#:                            &#34;&#34; =&amp;gt; &#34;1&#34;
  ingress.2603706321.cidr_blocks.#:     &#34;&#34; =&amp;gt; &#34;1&#34;
  ingress.2603706321.cidr_blocks.0:     &#34;&#34; =&amp;gt; &#34;0.0.0.0/0&#34;
  ingress.2603706321.from_port:         &#34;&#34; =&amp;gt; &#34;80&#34;
  ingress.2603706321.protocol:          &#34;&#34; =&amp;gt; &#34;tcp&#34;
  ingress.2603706321.security_groups.#: &#34;&#34; =&amp;gt; &#34;0&#34;
  ingress.2603706321.self:              &#34;&#34; =&amp;gt; &#34;0&#34;
  ingress.2603706321.to_port:           &#34;&#34; =&amp;gt; &#34;80&#34;
  name:                                 &#34;&#34; =&amp;gt; &#34;web-server-sg&#34;
  owner_id:                             &#34;&#34; =&amp;gt; &#34;&amp;lt;computed&amp;gt;&#34;
  tags.#:                               &#34;&#34; =&amp;gt; &#34;2&#34;
  tags.Made:                            &#34;&#34; =&amp;gt; &#34;terraform&#34;
  tags.Name:                            &#34;&#34; =&amp;gt; &#34;web-server&#34;
  vpc_id:                               &#34;&#34; =&amp;gt; &#34;vpc-d01806b2&#34;
aws_security_group.web-server: Creation complete

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.

The state of your infrastructure has been saved to the path
below. This state is required to modify and destroy your
infrastructure, so keep it safe. To inspect the complete state
use the `terraform show` command.

State path: terraform.tfstate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　&lt;code&gt;1 added&lt;/code&gt;となっています。&lt;code&gt;terraform show&lt;/code&gt;で今の状態を確認します。sg-8a53d6efができました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ terraform show                                                                         
aws_security_group.web-server:
  id = sg-8a53d6ef
  description = Allow traffic of webserver
  egress.# = 1
  egress.1965070075.cidr_blocks.# = 1
  egress.1965070075.cidr_blocks.0 = 0.0.0.0/0
  egress.1965070075.from_port = 0
  egress.1965070075.protocol = -1
  egress.1965070075.security_groups.# = 0
  egress.1965070075.self = false
  egress.1965070075.to_port = 0
  ingress.# = 1
  ingress.2603706321.cidr_blocks.# = 1
  ingress.2603706321.cidr_blocks.0 = 0.0.0.0/0
  ingress.2603706321.from_port = 80
  ingress.2603706321.protocol = tcp
  ingress.2603706321.security_groups.# = 0
  ingress.2603706321.self = false
  ingress.2603706321.to_port = 80
  name = web-server-sg
  owner_id = MY_AWS_ACCOUNT_NUMBER
  tags.# = 2
  tags.Made = terraform
  tags.Name = web-server
  vpc_id = vpc-d01806b2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　マネジメントコンソールでも、Terraformの指示通りのセキュリティグループが作成されたことが確認できます。&lt;/p&gt;

&lt;p&gt;　&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/03/2015-03-22-01.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;ルールの追加-inbound:29a47d36f0cb88ad8f2feca5cd4e2d83&#34;&gt;ルールの追加（Inbound）&lt;/h2&gt;

&lt;p&gt;　inboundにHTTPSを追加してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat web-sg.tf 
provider &#34;aws&#34; {
    access_key = &#34;${var.access_key}&#34;
    secret_key = &#34;${var.secret_key}&#34;
    region = &#34;${var.region}&#34;
}

resource &#34;aws_security_group&#34; &#34;web-server&#34; {
  name = &#34;web-server-sg&#34;
  description = &#34;Allow traffic of webserver&#34;

  ingress {
      from_port = 80 
      to_port = 80
      protocol = &#34;tcp&#34;
      cidr_blocks = [&#34;0.0.0.0/0&#34;]
  }
  ingress {
      from_port = 443
      to_port = 443
      protocol = &#34;tcp&#34;
      cidr_blocks = [&#34;0.0.0.0/0&#34;]
  }
  vpc_id = &#34;vpc-d01806b2&#34;
  tags {
    Name = &#34;web-server&#34;
    Made = &#34;terraform&#34;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　tfファイルを編集後、&lt;code&gt;terraform plan&lt;/code&gt;からの&lt;code&gt;terraform apply&lt;/code&gt;、&lt;code&gt;terraform show&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ terraform plan
Refreshing Terraform state prior to plan...

aws_security_group.web-server: Refreshing state... (ID: sg-8a53d6ef)

The Terraform execution plan has been generated and is shown below.
Resources are shown in alphabetical order for quick scanning. Green resources
will be created (or destroyed and then created if an existing resource
exists), yellow resources are being changed in-place, and red resources
will be destroyed.

Note: You didn&amp;#039;t specify an &#34;-out&#34; parameter to save this plan, so when
&#34;apply&#34; is called, Terraform can&amp;#039;t guarantee this is what will execute.

~ aws_security_group.web-server
    ingress.#:                            &#34;1&#34; =&amp;gt; &#34;2&#34;
    ingress.2603706321.cidr_blocks.#:     &#34;1&#34; =&amp;gt; &#34;1&#34;
    ingress.2603706321.cidr_blocks.0:     &#34;0.0.0.0/0&#34; =&amp;gt; &#34;0.0.0.0/0&#34;
    ingress.2603706321.from_port:         &#34;80&#34; =&amp;gt; &#34;80&#34;
    ingress.2603706321.protocol:          &#34;tcp&#34; =&amp;gt; &#34;tcp&#34;
    ingress.2603706321.security_groups.#: &#34;0&#34; =&amp;gt; &#34;0&#34;
    ingress.2603706321.self:              &#34;0&#34; =&amp;gt; &#34;0&#34;
    ingress.2603706321.to_port:           &#34;80&#34; =&amp;gt; &#34;80&#34;
    ingress.4089093546.cidr_blocks.#:     &#34;0&#34; =&amp;gt; &#34;1&#34;
    ingress.4089093546.cidr_blocks.0:     &#34;&#34; =&amp;gt; &#34;0.0.0.0/0&#34;
    ingress.4089093546.from_port:         &#34;&#34; =&amp;gt; &#34;443&#34;
    ingress.4089093546.protocol:          &#34;&#34; =&amp;gt; &#34;tcp&#34;
    ingress.4089093546.security_groups.#: &#34;0&#34; =&amp;gt; &#34;0&#34;
    ingress.4089093546.self:              &#34;&#34; =&amp;gt; &#34;0&#34;
    ingress.4089093546.to_port:           &#34;&#34; =&amp;gt; &#34;443&#34;


$ 
$ terraform apply
aws_security_group.web-server: Refreshing state... (ID: sg-8a53d6ef)
aws_security_group.web-server: Modifying...
  ingress.#:                            &#34;1&#34; =&amp;gt; &#34;2&#34;
  ingress.2603706321.cidr_blocks.#:     &#34;1&#34; =&amp;gt; &#34;1&#34;
  ingress.2603706321.cidr_blocks.0:     &#34;0.0.0.0/0&#34; =&amp;gt; &#34;0.0.0.0/0&#34;
  ingress.2603706321.from_port:         &#34;80&#34; =&amp;gt; &#34;80&#34;
  ingress.2603706321.protocol:          &#34;tcp&#34; =&amp;gt; &#34;tcp&#34;
  ingress.2603706321.security_groups.#: &#34;0&#34; =&amp;gt; &#34;0&#34;
  ingress.2603706321.self:              &#34;0&#34; =&amp;gt; &#34;0&#34;
  ingress.2603706321.to_port:           &#34;80&#34; =&amp;gt; &#34;80&#34;
  ingress.4089093546.cidr_blocks.#:     &#34;0&#34; =&amp;gt; &#34;1&#34;
  ingress.4089093546.cidr_blocks.0:     &#34;&#34; =&amp;gt; &#34;0.0.0.0/0&#34;
  ingress.4089093546.from_port:         &#34;&#34; =&amp;gt; &#34;443&#34;
  ingress.4089093546.protocol:          &#34;&#34; =&amp;gt; &#34;tcp&#34;
  ingress.4089093546.security_groups.#: &#34;0&#34; =&amp;gt; &#34;0&#34;
  ingress.4089093546.self:              &#34;&#34; =&amp;gt; &#34;0&#34;
  ingress.4089093546.to_port:           &#34;&#34; =&amp;gt; &#34;443&#34;
aws_security_group.web-server: Modifications complete

Apply complete! Resources: 0 added, 1 changed, 0 destroyed.

The state of your infrastructure has been saved to the path
below. This state is required to modify and destroy your
infrastructure, so keep it safe. To inspect the complete state
use the `terraform show` command.

State path: terraform.tfstate
$ 
$ terraform show
aws_security_group.web-server:
  id = sg-8a53d6ef
  description = Allow traffic of webserver
  egress.# = 1
  egress.1965070075.cidr_blocks.# = 1
  egress.1965070075.cidr_blocks.0 = 0.0.0.0/0
  egress.1965070075.from_port = 0
  egress.1965070075.protocol = -1
  egress.1965070075.security_groups.# = 0
  egress.1965070075.self = false
  egress.1965070075.to_port = 0
  ingress.# = 2
  ingress.2603706321.cidr_blocks.# = 1
  ingress.2603706321.cidr_blocks.0 = 0.0.0.0/0
  ingress.2603706321.from_port = 80
  ingress.2603706321.protocol = tcp
  ingress.2603706321.security_groups.# = 0
  ingress.2603706321.self = false
  ingress.2603706321.to_port = 80
  ingress.4089093546.cidr_blocks.# = 1
  ingress.4089093546.cidr_blocks.0 = 0.0.0.0/0
  ingress.4089093546.from_port = 443
  ingress.4089093546.protocol = tcp
  ingress.4089093546.security_groups.# = 0
  ingress.4089093546.self = false
  ingress.4089093546.to_port = 443
  name = web-server-sg
  owner_id = MY_AWS_ACCOUNT_NUMBER
  tags.# = 2
  tags.Made = terraform
  tags.Name = web-server
  vpc_id = vpc-d01806b2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　&lt;code&gt;1 changed&lt;/code&gt;となっています。既存のリソースに変更が発生しました。マネジメントコンソール上で確認すると、inboundにHTTPSが増えています。&lt;/p&gt;

&lt;p&gt;　&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/03/2015-03-22-02.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;

&lt;h2 id=&#34;ルールの追加-outbound:29a47d36f0cb88ad8f2feca5cd4e2d83&#34;&gt;ルールの追加（Outbound）&lt;/h2&gt;

&lt;p&gt;　新たにサポートされたegressも使ってみます。sg-2da11148がNATインスタンスに適用されている体で、sg-2da11148向けのOutbound全通信を許可するルールを追加します。&lt;/p&gt;

&lt;p&gt;　許可対象にセキュリティグループを利用する時は、&lt;code&gt;cidr_blocks&lt;/code&gt;ではなく&lt;code&gt;security_groups&lt;/code&gt;を利用します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat web-sg.tf 
provider &#34;aws&#34; {
    access_key = &#34;${var.access_key}&#34;
    secret_key = &#34;${var.secret_key}&#34;
    region = &#34;${var.region}&#34;
}

resource &#34;aws_security_group&#34; &#34;web-server&#34; {
  name = &#34;web-server-sg&#34;
  description = &#34;Allow traffic of webserver&#34;

  ingress {
      from_port = 80 
      to_port = 80
      protocol = &#34;tcp&#34;
      cidr_blocks = [&#34;0.0.0.0/0&#34;]
  }
  ingress {
      from_port = 443
      to_port = 443
      protocol = &#34;tcp&#34;
      cidr_blocks = [&#34;0.0.0.0/0&#34;]
  }
  egress {
      from_port = 0
      to_port = 65535
      protocol = &#34;-1&#34;
      security_groups = [&#34;sg-2da11148&#34;]
  }
  vpc_id = &#34;vpc-d01806b2&#34;
  tags {
    Name = &#34;web-server&#34;
    Made = &#34;terraform&#34;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　tfファイルを編集後、&lt;code&gt;terraform plan&lt;/code&gt;からの&lt;code&gt;terraform apply&lt;/code&gt;、&lt;code&gt;terraform show&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  terraform plan
Refreshing Terraform state prior to plan...

aws_security_group.web-server: Refreshing state... (ID: sg-8a53d6ef)

The Terraform execution plan has been generated and is shown below.
Resources are shown in alphabetical order for quick scanning. Green resources
will be created (or destroyed and then created if an existing resource
exists), yellow resources are being changed in-place, and red resources
will be destroyed.

Note: You didn&amp;#039;t specify an &#34;-out&#34; parameter to save this plan, so when
&#34;apply&#34; is called, Terraform can&amp;#039;t guarantee this is what will execute.

~ aws_security_group.web-server
    egress.2221449193.cidr_blocks.#:              &#34;0&#34; =&amp;gt; &#34;0&#34;
    egress.2221449193.from_port:                  &#34;&#34; =&amp;gt; &#34;0&#34;
    egress.2221449193.protocol:                   &#34;&#34; =&amp;gt; &#34;-1&#34;
    egress.2221449193.security_groups.#:          &#34;0&#34; =&amp;gt; &#34;1&#34;
    egress.2221449193.security_groups.1429001686: &#34;&#34; =&amp;gt; &#34;sg-2da11148&#34;
    egress.2221449193.self:                       &#34;&#34; =&amp;gt; &#34;0&#34;
    egress.2221449193.to_port:                    &#34;&#34; =&amp;gt; &#34;65535&#34;


$ terraform apply
aws_security_group.web-server: Refreshing state... (ID: sg-8a53d6ef)
aws_security_group.web-server: Modifying...
  egress.2221449193.cidr_blocks.#:              &#34;0&#34; =&amp;gt; &#34;0&#34;
  egress.2221449193.from_port:                  &#34;&#34; =&amp;gt; &#34;0&#34;
  egress.2221449193.protocol:                   &#34;&#34; =&amp;gt; &#34;-1&#34;
  egress.2221449193.security_groups.#:          &#34;0&#34; =&amp;gt; &#34;1&#34;
  egress.2221449193.security_groups.1429001686: &#34;&#34; =&amp;gt; &#34;sg-2da11148&#34;
  egress.2221449193.self:                       &#34;&#34; =&amp;gt; &#34;0&#34;
  egress.2221449193.to_port:                    &#34;&#34; =&amp;gt; &#34;65535&#34;
aws_security_group.web-server: Modifications complete

Apply complete! Resources: 0 added, 1 changed, 0 destroyed.

The state of your infrastructure has been saved to the path
below. This state is required to modify and destroy your
infrastructure, so keep it safe. To inspect the complete state
use the `terraform show` command.

State path: terraform.tfstate
$ terraform show
aws_security_group.web-server:
  id = sg-8a53d6ef
  description = Allow traffic of webserver
  egress.# = 1
  egress.2221449193.cidr_blocks.# = 0
  egress.2221449193.from_port = 0
  egress.2221449193.protocol = -1
  egress.2221449193.security_groups.# = 1
  egress.2221449193.security_groups.1429001686 = sg-2da11148
  egress.2221449193.self = false
  egress.2221449193.to_port = 65535
  ingress.# = 2
  ingress.2603706321.cidr_blocks.# = 1
  ingress.2603706321.cidr_blocks.0 = 0.0.0.0/0
  ingress.2603706321.from_port = 80
  ingress.2603706321.protocol = tcp
  ingress.2603706321.security_groups.# = 0
  ingress.2603706321.self = false
  ingress.2603706321.to_port = 80
  ingress.4089093546.cidr_blocks.# = 1
  ingress.4089093546.cidr_blocks.0 = 0.0.0.0/0
  ingress.4089093546.from_port = 443
  ingress.4089093546.protocol = tcp
  ingress.4089093546.security_groups.# = 0
  ingress.4089093546.self = false
  ingress.4089093546.to_port = 443
  name = web-server-sg
  owner_id = MY_AWS_ACCOUNT_NUMBER
  tags.# = 2
  tags.Made = terraform
  tags.Name = web-server
  vpc_id = vpc-d01806b2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　1 changed　となっています。既存のリソースに変更が発生しています。マネジメントコンソール上で確認すると、outboundにsg-2da11148向けのALL Trafficが増えています。&lt;/p&gt;

&lt;p&gt;　&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/03/2015-03-22-03.png&#34; alt=&#34;&#34; /&gt;
&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terraformのroot_block_deviceを使う</title>
      <link>http://aimless.jp/blog/archives/2439</link>
      <pubDate>Mon, 09 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2439</guid>
      <description>

&lt;p&gt;Terraformのroot_block_deviceで躓いたのでメモ。&lt;/p&gt;

&lt;h2 id=&#34;やりたいこと:bf37395249d323f0a481b0db49ec8488&#34;&gt;やりたいこと&lt;/h2&gt;

&lt;p&gt;　Terraformを利用して、10Gのルートデバイスと20Gのブロックデバイスを持ったt2.microのインスタンスを起動する&lt;/p&gt;

&lt;h2 id=&#34;やったこと:bf37395249d323f0a481b0db49ec8488&#34;&gt;やったこと&lt;/h2&gt;

&lt;p&gt;　クレデンシャルを記載したtfファイルを作成する&lt;/p&gt;

&lt;p&gt;　リソース作成の処理を記載したtfファイルを作成する&lt;/p&gt;

&lt;p&gt;　処理で利用する変数ファイルをまとめて定義するtfファイルを作成する&lt;/p&gt;

&lt;p&gt;　terraform実行時に渡す変数をまとめたtfファイルを作成する&lt;/p&gt;

&lt;p&gt;　terraformする。&lt;/p&gt;

&lt;h2 id=&#34;失敗談:bf37395249d323f0a481b0db49ec8488&#34;&gt;失敗談&lt;/h2&gt;

&lt;p&gt;　ebs_root_device_nameの値をAMIのルートデバイス名と異なる値にしたところ、root_block_deviceのパラメータが追加のブロックデバイスとして判断されてしまった。&lt;/p&gt;

&lt;p&gt;　たとえば、Amazon Linuxに対してebs_root_device_nameを指定しないと、デフォルト値である/dev/sda1が利用されてしまい、ルートデバイスはAMIのデフォルト、そのほかにブロックデバイスが追加で2個EBSが作成されてしまう。&lt;/p&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;h3 id=&#34;失敗の事例:bf37395249d323f0a481b0db49ec8488&#34;&gt;失敗の事例&lt;/h3&gt;

&lt;p&gt;　ebs_root_device_nameを指定せずにterraformしたログは以下の通り。terraform plan ではルートデバイス1個、ブロックデバイス1個となっているが、terraform applyしてみると、block_device.# = 2になっている。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>業務時間外にEC2を停止する</title>
      <link>http://aimless.jp/blog/archives/2429</link>
      <pubDate>Thu, 26 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2429</guid>
      <description>&lt;p&gt;AWS上に複数人が利用する開発用サーバを立てました。24時間365日稼働させる必要はありませんが、手作業で起動・停止を行うのも馬鹿げています。&lt;/p&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;p&gt;　そこで、業務時間外に対象インスタンスを停止し、始業前に対象インスタンスを開始するスクリプトを書いて、NATインスタンス上のcronで実行してみました。&lt;/p&gt;

&lt;p&gt;　ちゃんと動いていますが、以下の様な点を修正する必要がありますね。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AWS CLIの実行結果が標準出力となり、ec2-userにメールが届いてしまう&lt;/li&gt;
&lt;li&gt;万が一起動に失敗した場合、他のメンバーに迷惑がかかるので、メール通知したい。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>セキュリティグループの詳細をCSV形式で出力する</title>
      <link>http://aimless.jp/blog/archives/2418</link>
      <pubDate>Mon, 23 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2418</guid>
      <description>&lt;p&gt;セキュリティグループにルールを追加すればするほどマネジメントコンソールでの一覧性が下がるので、全てのルールをCSV形式でエクスポートするコマンドを作ってみました。aws-to-csvです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kongou-ae/aws-to-csv&#34;&gt;kongou-ae/aws-to-csv&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./a2csv securityGroups -r ap-northeast-1 -p private
GroupID,Direction,Type,Protocol,Port Range,IP Range
sg-b6822ed3,inbound,ALL ICMP,ICMP(1),ALL,sg-a9822ecc
sg-b6822ed3,outbound,ALL Traffic,ALL,ALL,0.0.0.0/0
sg-6ad86e0f,inbound,SSH(22),TCP(6),22,0.0.0.0/0
sg-6ad86e0f,outbound,ALL Traffic,ALL,ALL,0.0.0.0/0
sg-f07cdd95,inbound,RDP(3389),TCP(6),3389,192.168.11.1/32
sg-f07cdd95,outbound,ALL Traffic,ALL,ALL,0.0.0.0/0
sg-a9822ecc,inbound,ALL Traffic,ALL,ALL,192.168.11.1/32
sg-a9822ecc,outbound,ALL ICMP,ICMP(1),ALL,sg-b6822ed3
sg-aa2686cf,inbound,Custom Rrotocol Rule,HOPOPT(0),ALL,sg-6ad86e0f
sg-aa2686cf,inbound,SSH(22),TCP(6),22,192.168.11.1/32
sg-aa2686cf,outbound,ALL Traffic,ALL,ALL,0.0.0.0/0
sg-b10aecd4,inbound,SSH(22),TCP(6),22,0.0.0.0/0
sg-b10aecd4,outbound,ALL Traffic,ALL,ALL,0.0.0.0/0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　セキュリティグループは、APIのレスポンスをそのままCSV形式でエクスポートすると、出力内容がマネジメントコンソールの表示と大きく異なってしまい可読性が低くなります。そこで、APIのレスポンスをあの手この手で細工してからCSV形式で出力するようにしています。&lt;/p&gt;

&lt;p&gt;　今までpythonで遊んでいましたが、今回は、クロスコンパイルにあこがれてgolangを使ってみました。これはすごいですね。VPSでwindows用にコンパイルしたa2csv.exeが、会社のwindows端末でそのまま動く。pythonで書いたコードを使うために、会社のPCにpythonをインストールしていたのが馬鹿みたいです。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Amazon LinuxにLodgeをインストールした</title>
      <link>http://aimless.jp/blog/archives/2408</link>
      <pubDate>Thu, 19 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2408</guid>
      <description>&lt;p&gt;Amazon Linuxにナレッジ/ノウハウ情報共有サービスのOSS「Lodge」をインストールしたので手順をメモしておきます。取りあえず動かすことが目的です。&lt;/p&gt;

&lt;p&gt;　ブラウザから「ec2-xxx-xxx-xxx-xxx.ap-northeast-1.compute.amazonaws.com:3000」にアクセスしてログイン画面が出れば成功です。TCP/3000をセキュリティグループで許可することを忘れずに。&lt;/p&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;p&gt;　また、TCP/3000でのアクセスは不便だったので、前段にNginx等のリバースプロキシを置いてTCP/80でアクセスできるようにしました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AWS上のオンデマンドなUTM製品を比較する</title>
      <link>http://aimless.jp/blog/archives/2399</link>
      <pubDate>Mon, 16 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2399</guid>
      <description>&lt;p&gt;イマイチ使いどころが見つけられないAWS上のUTM製品について、オンデマンド版（ライセンスこみで使えるAMI）の費用を比較しました。&lt;/p&gt;

&lt;p&gt;　なお、AWS上には、Barracuda NG FirewallやPaloalto VM-Seriesもあるのですが、これらはオンデマンド版が存在せずBYOL版のみのため、記載していません。オンデマンド版があれば、評価しやすいのに。。。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;インスタンスタイプ&lt;/th&gt;
&lt;th&gt;FortiGate-VM&lt;/th&gt;
&lt;th&gt;CheckPoint VA&lt;/th&gt;
&lt;th&gt;sophos-UTM 9&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;t1.micro&lt;/td&gt;
&lt;td&gt;&amp;#8211;&lt;/td&gt;
&lt;td&gt;&amp;#8211;&lt;/td&gt;
&lt;td&gt;$0.02/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;t1.small&lt;/td&gt;
&lt;td&gt;&amp;#8211;&lt;/td&gt;
&lt;td&gt;&amp;#8211;&lt;/td&gt;
&lt;td&gt;$0.264/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m3.medium&lt;/td&gt;
&lt;td&gt;$0.37/hr&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;$0.42/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m3.large&lt;/td&gt;
&lt;td&gt;$0.95/hr&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;$0.84/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m3.xlarge&lt;/td&gt;
&lt;td&gt;$2.13/hr&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;$1.68/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m3.2xlarge&lt;/td&gt;
&lt;td&gt;$4.49/hr&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;$3.36/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c3.large&lt;/td&gt;
&lt;td&gt;$0.835/hr&lt;/td&gt;
&lt;td&gt;$1.815/hr&lt;/td&gt;
&lt;td&gt;$0.525/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c3.xlarge&lt;/td&gt;
&lt;td&gt;$1.87/hr&lt;/td&gt;
&lt;td&gt;$2.80/hr&lt;/td&gt;
&lt;td&gt;$1.05/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c3.2xlarge&lt;/td&gt;
&lt;td&gt;$3.95/hr&lt;/td&gt;
&lt;td&gt;$4.86/hr&lt;/td&gt;
&lt;td&gt;$2.10/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c3.4xlarge&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;$6.483/hr&lt;/td&gt;
&lt;td&gt;$4.20/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c3.8xlarge&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;$8.688/hr&lt;/td&gt;
&lt;td&gt;$8.40/hr&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
  </channel>
</rss>