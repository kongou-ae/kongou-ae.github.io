<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aws on Aimless</title>
    <link>http://aimless.jp/categories/aws/</link>
    <description>Recent content in Aws on Aimless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Tue, 15 Dec 2015 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://aimless.jp/categories/aws/feed/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Amazon WorkSpacesのRemember Me機能を使う</title>
      <link>http://aimless.jp/blog/archives/2015-12-15-aws-workspaces-with-remember-me</link>
      <pubDate>Tue, 15 Dec 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2015-12-15-aws-workspaces-with-remember-me</guid>
      <description>

&lt;p&gt;Amazon WorkSpacesへの憧れが止まりません。BYOD＋WorkSpacesで仕事がしたい。とはいえ、古きSIerである弊社において、いきなりBYODはレベルが高すぎます。そこで、自宅からのリモートアクセス用途として会社に対してWorkSpacesを提案することにしました。そのために色々と調べたのでメモしておきます。&lt;/p&gt;

&lt;h2 id=&#34;mfaの罠:31f38dca8007ccf1ee688b8fda274f87&#34;&gt;MFAの罠&lt;/h2&gt;

&lt;p&gt;　AD ConnectorとRADIUSサーバによる多要素認証を使ってみて気が付いたのですが、WorkSpacesクライアントは多要素認証を使っていても認証情報を記憶します。多要素認証でログインした後に一旦切断しても、以下の画面になりボタン一つで簡単に再接続ができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://media.amazonwebservices.com/blog/2015/ws_client_reconnect_2.png&#34; alt=&#34;https://media.amazonwebservices.com/blog/2015/ws_client_reconnect_2.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　認証情報を保存する機能は便利なのですが、社外に配置するPCで利用するWorkSpacesクライアントには認証情報を保存したくありません。誰が触るかわかりませんので。&lt;/p&gt;

&lt;h2 id=&#34;remember-meの無効化:31f38dca8007ccf1ee688b8fda274f87&#34;&gt;Remember Meの無効化&lt;/h2&gt;

&lt;p&gt;　ドキュメントを調べたところ、ぴったりな機能がありました。Remember Meの無効化です。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/workspaces/latest/adminguide/osx_client_help.htm&#34;&gt;Amazon WorkSpaces クライアントのヘルプ&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Amazon WorkSpaces 管理者が [Remember Me] 機能を無効にしていない場合、それ以降 WorkSpace に簡単に接続できるように、自分の認証情報を安全に保存しておくかどうかを確認するメッセージが表示されます。認証情報は、ユーザーの Kerberos チケットの最大有効期間が終了するまで安全にキャッシュに保存されます。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現時点で、Remember Meの無効化はサポートにお願いする必要があります。マネジメントコンソールでは無効にできません。&lt;/p&gt;

&lt;h2 id=&#34;remember-me無効後の動作:31f38dca8007ccf1ee688b8fda274f87&#34;&gt;Remember Me無効後の動作&lt;/h2&gt;

&lt;p&gt;WorkSpacesクライアントを切断します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/images/2015-12-15-002.png&#34; alt=&#34;http://aimless.jp/blog/images/2015-12-15-002.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;切断後の画面がRecconectになりません。IDとパスワード、ワンタイムパスワードを入力する画面に戻りました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/images/2015-12-15-003.png&#34; alt=&#34;http://aimless.jp/blog/images/2015-12-15-003.png&#34; /&gt;&lt;/p&gt;

&lt;p&gt;WorkSpacesクライアントのオプション設定でもRemember Meを有効にすることができなくなります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/images/2015-12-15-004.png&#34; alt=&#34;http://aimless.jp/blog/images/2015-12-15-004.png&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;所感:31f38dca8007ccf1ee688b8fda274f87&#34;&gt;所感&lt;/h2&gt;

&lt;p&gt;WorkSpacesはどこでもどんな端末でも使えるのが最大のメリットだと思います。ですが、どこでも使える端末に社内ネットワークにアクセスするための認証情報を保存するのはリスクがあります。Remember Meの無効化は、利便性とセキュリティを両立させる良いオプションだと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>aws2excelを作ってみた</title>
      <link>http://aimless.jp/blog/archives/2684</link>
      <pubDate>Sun, 15 Nov 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2684</guid>
      <description>

&lt;h2 id=&#34;作ったもの:d4fd824ade6bd5facb61487e58730a29&#34;&gt;作ったもの&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kongou-ae/aws2excel&#34;&gt;kongou-ae/aws2excel&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;AWSの構成情報をxlsxファイルに書き出すスクリプトです。出力されるファイルのイメージはREADMEの画像を参照ください。勢いでやっつけているので、一部サービスにのみ対応しています。最終的にはLambdaで動かしてs3にExcelを吐き出す実装にしたい。&lt;/p&gt;

&lt;h2 id=&#34;経緯:d4fd824ade6bd5facb61487e58730a29&#34;&gt;経緯&lt;/h2&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/ishikawa84g&#34;&gt;@ishikawa84g&lt;/a&gt; cloud2excel!&lt;/p&gt;&amp;mdash; 前佛 雅人(M.Zembutsu) (@zembutsu) &lt;a href=&#34;https://twitter.com/zembutsu/status/660383609283457024&#34;&gt;2015, 10月 31&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/ishikawa84g&#34;&gt;@ishikawa84g&lt;/a&gt; 残念ながら夢の中のお話です…&lt;/p&gt;&amp;mdash; 前佛 雅人(M.Zembutsu) (@zembutsu) &lt;a href=&#34;https://twitter.com/zembutsu/status/660384559700176896&#34;&gt;2015, 10月 31&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/ishikawa84g&#34;&gt;@ishikawa84g&lt;/a&gt; ごめんなさい…ごめんなさいｗ&lt;/p&gt;&amp;mdash; 前佛 雅人(M.Zembutsu) (@zembutsu) &lt;a href=&#34;https://twitter.com/zembutsu/status/660384991096868865&#34;&gt;2015, 10月 31&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;自分もワクワクしながらcloud2excelを検索しまして、、、無いのであれば、勉強がてら作ってみようということで作ってみました。&lt;/p&gt;

&lt;h2 id=&#34;実装:d4fd824ade6bd5facb61487e58730a29&#34;&gt;実装&lt;/h2&gt;

&lt;p&gt;aws-sdkを利用してAPIを叩き必要な情報を取得し、その情報をExcel に書き出しているだけです。Excelへの書き出しは&lt;a href=&#34;https://github.com/guyonroche/exceljs&#34;&gt;guyonroche/exceljs&lt;/a&gt;を使いました。&lt;/p&gt;

&lt;h2 id=&#34;雑感:d4fd824ade6bd5facb61487e58730a29&#34;&gt;雑感&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/guyonroche/exceljs&#34;&gt;guyonroche/exceljs&lt;/a&gt;を見つけたのが今回の最大の収穫です。配列やオブジェクトの情報を、かなり簡単に表形式でExcelに書き出すことができます。さらに、&lt;a href=&#34;https://github.com/guyonroche/exceljs&#34;&gt;guyonroche/exceljs&lt;/a&gt;は、Excelからの読み込みもできるようなので、Infrastrucrture as Excelが実現できます。Excelでパラメータシートを作り、そこにパラメータを書くとAWS上にインスタンスができる。なんという黒魔術。やりませんけど。。。&lt;/p&gt;

&lt;p&gt;また、Node.jsの非同期処理に苦戦しました。async.jsを使っており期待する動作はしているものの、正しい使い方かどうか不安です。Node.js（というかJavascript）を体系的に学びたい。&lt;/p&gt;

&lt;p&gt;今後は、issueにもある通り、コードを分割してメンテナンス性を高め、ELBやRDSなどメジャーなサービスに対応しようと思います。仕事の本業はAWSではないので、プライベートで淡々とメンテしていきます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Amazon LinuxにZabbix3.0をインストールしてハマった事</title>
      <link>http://aimless.jp/blog/archives/2682</link>
      <pubDate>Mon, 26 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2682</guid>
      <description>

&lt;p&gt;Zabbix3.0（アルファ版）のソースが公開されていたので、Amazon Linuxにインストールを試みました。その際にはまったことをメモしておきます。ハマったといっても、マニュアルのRequirementsを読んでからインストールを始めれば、全くハマらないポイントです。。。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zabbix.com/documentation/3.0/&#34;&gt;Zabbix Documentation 3.0&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Amazon Linuxのバージョン：2015.09&lt;/li&gt;
&lt;li&gt;Zabbixのバージョン：3.0.0 alpha3&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;サポートするphpのバージョンが5-4-0以上である:36b14705263dd1ce094510eba4cf7e4c&#34;&gt;サポートするPHPのバージョンが5.4.0以上である&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/images/2015-10-26-001.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　Amazon Linuxで何も考えずに&lt;code&gt;sudo yum install php php-gd php-bcmath php-mysql php-mbstring&lt;/code&gt;すると、インストールされるPHPのバージョンは5.3になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;============================================================================================================================
 Package                       Arch                    Version                             Repository                  Size
============================================================================================================================
Installing:
 php                           x86_64                  5.3.29-1.8.amzn1                    amzn-main                  2.8 M
 php-bcmath                    x86_64                  5.3.29-1.8.amzn1                    amzn-main                   52 k
 php-gd                        x86_64                  5.3.29-1.8.amzn1                    amzn-main                  219 k
 php-mbstring                  x86_64                  5.3.29-1.8.amzn1                    amzn-main                  2.3 M
 php-mysql                     x86_64                  5.3.29-1.8.amzn1                    amzn-main                  178 k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　Zabbix3.0は、php5.3をサポートしていません。php5.4以上をサポートしています。&lt;code&gt;sudo yum install php54 php54-gd php54-bcmath php54-mysql php54-mbstring&lt;/code&gt;でphp5.4をインストールするようにしましょう。&lt;/p&gt;

&lt;h2 id=&#34;php5-4がapache2-4系に依存している:36b14705263dd1ce094510eba4cf7e4c&#34;&gt;php5.4がapache2.4系に依存している&lt;/h2&gt;

&lt;p&gt;　apache2.2がインストールされている場合、php5.3をyum removeし、いざphp5.4系をyum installしようとしても、依存エラーになります。&lt;/p&gt;

&lt;p&gt;　これはphp5.4がapache2.4に依存しているためです。php5.4が必要とするapache2.4が、元々入っているapache2.2と競合してしまうためにエラーとなります。apache2.2系のパッケージを削除してからphp54のインストールを行いましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ sudo yum install php54 php54-gd php54-bcmath php54-mysql php54-mbstring
Loaded plugins: priorities, update-motd, upgrade-helper
Resolving Dependencies
--&amp;gt; Running transaction check
---&amp;gt; Package php54.x86_64 0:5.4.45-1.75.amzn1 will be installed
--&amp;gt; Processing Dependency: httpd-mmn = 20120211x86-64 for package: php54-5.4.45-1.75.amzn1.x86_64
--&amp;gt; Processing Dependency: php54-common(x86-64) = 5.4.45-1.75.amzn1 for package: php54-5.4.45-1.75.amzn1.x86_64
--&amp;gt; Processing Dependency: php54-cli(x86-64) = 5.4.45-1.75.amzn1 for package: php54-5.4.45-1.75.amzn1.x86_64
--&amp;gt; Processing Dependency: httpd24 for package: php54-5.4.45-1.75.amzn1.x86_64
（中略）
--&amp;gt; Finished Dependency Resolution
Error: httpd24-tools conflicts with httpd-tools-2.2.31-1.6.amzn1.x86_64
Error: httpd24 conflicts with httpd-2.2.31-1.6.amzn1.x86_64
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Lambdaファンクションを雑に監視する</title>
      <link>http://aimless.jp/blog/archives/2681</link>
      <pubDate>Sun, 25 Oct 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2681</guid>
      <description>

&lt;h2 id=&#34;lambdaへの切り替え:6d0ff38d6f824570d13427bb9cb52ec6&#34;&gt;Lambdaへの切り替え&lt;/h2&gt;

&lt;p&gt;　Lambdaがスケジュール実行に対応しました。そこで、サーバレスアーキテクチャを実践すべく、conohaで動いている＠ipv6kumaの機能を、AWSに順次お引越ししています。本日時点で、以下のフルルート数とフルルートグラフのツイートはLambdaでお伝えしています。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;2015/10/25の経路数は24457だクマー。昨日と比べて35経路増えたクマ！！ /from Lambda&lt;/p&gt;&amp;mdash; ブイロクマ (@IPv6kuma) &lt;a href=&#34;https://twitter.com/IPv6kuma/status/658221773335334912&#34;&gt;2015, 10月 25&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;本日までの経路数をグラフにしたクマ!! &lt;a href=&#34;https://t.co/Z9jHt6yXnT&#34;&gt;https://t.co/Z9jHt6yXnT&lt;/a&gt;&lt;/p&gt;&amp;mdash; ブイロクマ (@IPv6kuma) &lt;a href=&#34;https://twitter.com/IPv6kuma/status/658221776074244097&#34;&gt;2015, 10月 25&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&#34;lambdaを監視する:6d0ff38d6f824570d13427bb9cb52ec6&#34;&gt;Lambdaを監視する&lt;/h2&gt;

&lt;p&gt;　さて、Lambdaファンクションを書いていて気になった事があります。それは『Lambdaファンクションが正しく動作している事をどうやって監視するか』です。&lt;/p&gt;

&lt;p&gt;　現時点での＠ipv6kumaは、エラーハンドリングを書いていません。想定通りに動作した最後の箇所に&lt;code&gt;context.done()&lt;/code&gt;を記載しているだけです。したがって、エラーが起きると&lt;code&gt;context.done()&lt;/code&gt;が呼び出されないので、ログには必ず&lt;code&gt;Process exited before completing request&lt;/code&gt;が出現します。&lt;/p&gt;

&lt;p&gt;　そこで、この文言をcloudwatch logsのMetric Filterを利用して監視することで、Lambdaファンクションが想定通りに動いているかどうかを監視することにしました。&lt;/p&gt;

&lt;h2 id=&#34;設定方法:6d0ff38d6f824570d13427bb9cb52ec6&#34;&gt;設定方法&lt;/h2&gt;

&lt;p&gt;　監視したいログを選択し、&lt;code&gt;Create Metric Filter&lt;/code&gt;を選択。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/images/2015-10-25-00.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　&lt;code&gt;Filter Pattern&lt;/code&gt;に&lt;code&gt;Process exited before completing request&lt;/code&gt;を入力して次に進む&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/images/2015-10-25-01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　&lt;code&gt;Metric Name&lt;/code&gt;の欄に、カスタムメトリック名を入力し&lt;code&gt;Save Filter&lt;/code&gt;を押下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/images/2015-10-25-02.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　メトリックフィルターができました。このフィルターに紐づくアラームを作成します。&lt;code&gt;Create Alarm&lt;/code&gt;を押下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/images/2015-10-25-03.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　必要なパラメータを入力します。Metric Filter作成時にMetricを1にしましたので、アラームの閾値は1以上とします。ActionにSNSを通知することで、エラーの発生をメールで通知します。ipv6kuma_errorのサブスクライバーは私の個人アドレスになっています。&lt;/p&gt;

&lt;p&gt;　最後に&lt;code&gt;Create Alarm&lt;/code&gt;を押下&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/images/2015-10-25-04.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　アラームつきのMetric Filterができました！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/images/2015-10-25-05.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;動作確認:6d0ff38d6f824570d13427bb9cb52ec6&#34;&gt;動作確認&lt;/h2&gt;

&lt;p&gt;　@ipv6kumaはエラーを起こすのが大変なので、別のLambdaファンクションに同様の監視を実装して、&lt;code&gt;Process exited before completing request&lt;/code&gt;を発生させました。&lt;/p&gt;

&lt;p&gt;　少々待つと、CloudwatchのエラーがSNS経由で通知されました。これで@ipv6kumaに何かあった場合、気が付くことができます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/images/2015-10-25-06.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>API Gateway &#43; Lambdaを使って、マルチクラウド管理APIを作る</title>
      <link>http://aimless.jp/blog/archives/2679</link>
      <pubDate>Sat, 18 Jul 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2679</guid>
      <description>&lt;p&gt;「単一のREST APIで複数のクラウドを操作できたら便利だろうなー」と思い調べてみたところ、以下のようなライブラリを見つけました。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;言語&lt;/th&gt;
&lt;th&gt;ライブラリ&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Ruby&lt;/td&gt;
&lt;td&gt;DeltaCloud&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Python&lt;/td&gt;
&lt;td&gt;libcloud&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Node.js&lt;/td&gt;
&lt;td&gt;pkgcloud&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;Golang&lt;/td&gt;
&lt;td&gt;Gophercloud&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　ライブラリによってサポートするクラウドプロバイダーが異なり、さらに管理できるサービスと管理できないサービスがあります。どれか一つのライブラリと心中するのは、少々リスクだと思いました。&lt;/p&gt;

&lt;p&gt;　「何か他にいい方法はないかなー」と調べていたところに、Amazon API Gatewayがリリースされました。API Gatewayを利用すると、API Gateway経由でLambdaを実行することができます。LambdaではNode.jsとjavaが動きます。主要なクラウドにはNode.jsやjavaのSDKが存在します。つまり、API Gatewayを利用すれば、自分のやりたいことができる、マルチクラウド管理APIを作れそうな気がしました。&lt;/p&gt;

&lt;p&gt;　というわけで実践。AzureとAWSのインスタンス情報をまとめて返すAPIを作ってみます。&lt;/p&gt;

&lt;p&gt;　API Gatewayでは、/computeがGETされた場合にLambdaファンクションを発火するようにします。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/07/api_gateway_setting.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　そして、対応するLambdaファンクションでは以下のコードを動かします。SDKを利用して各クラウドのインスタンス情報を取得し配列に格納し、その配列を返すスクリプトです。&lt;/p&gt;

&lt;p&gt;　とりあえずということで、認証情報の扱いは適当です。AWSの認証情報はコード内にベタ書きします。Azureの証明書は、lambdaファンクションのZIPに含めます。実際のところは、API Gatewayにアクセスする際のHTTPヘッダに認証情報を含め、Lambdaファンクションに渡す方法がカッコいいと思います。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kongou-ae/ad0b1366da2ee5efbbaa.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;　ブラウザでAPI Gatewayの/computeにアクセスすると、以下のJSONが返ってきます。AzureとAWSのインスタンス情報が一つのJSONのレスポンスになっています。いい感じですね。このレスポンスをJavascriptでいい感じに表示するHTMLを作ってS3に配置すれば、サーバレスのマルチクラウド管理ポータルが作れるかも？&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kongou-ae/825a49a087311e0814ad.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/07/result_of_api.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>VPC FLow Logsを継続的にElasticSearchに投入する</title>
      <link>http://aimless.jp/blog/archives/2617</link>
      <pubDate>Sun, 14 Jun 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2617</guid>
      <description>

&lt;p&gt;VPC FLow Logsのリリース直後から、クラメソさんの「&lt;a href=&#34;http://dev.classmethod.jp/cloud/aws/vpc-flow-logs-visualized-kibana4/&#34;&gt;VPC Flow LogsをElasticsearch + Kibana4で可視化する&lt;/a&gt;」と同じことを考えていました。週末に試行錯誤した結果をアウトプットします。&lt;/p&gt;

&lt;h2 id=&#34;ログの取り方:879fe74068b1e39f8423ed492442144f&#34;&gt;ログの取り方&lt;/h2&gt;

&lt;p&gt;　AWS SDK for Ruby を利用してClodWatch Logsを取得する方法は以下の様になります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# coding: utf-8

require &amp;#039;aws-sdk-core&amp;#039;

cloudwatchlogs = Aws::CloudWatchLogs::Client.new(region: region )

# cloudwatchlogs.get_log_eventsのオプションを定義
options = {
    log_group_name: log_group_name,
    log_stream_name: log_stream_name,
}

# ログを取得
resp = cloudwatchlogs.get_log_events(options)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　ただし、この方法でログを取得した場合、指定したlog_streamに格納されている大量のデータがレスポンスとして帰ってきます。デフォルトでは最大で1M Byte分のログが取得するようです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/sdkforruby/api/Aws/CloudWatchLogs/Client.html#get_log_events-instance_method&#34;&gt;Class: Aws::CloudWatchLogs::Client&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;By default, this operation returns as much log events as can fit in a response size of 1MB, up to 10,000 log events.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　したがって、このコードを継続的に実行すると、最初から1M byte分のログを繰り返し取得してしまいます。これでは意味がありません。実行時には、前回実行分以降のログを取得してほしい。これを実現する方法が、&lt;code&gt;get_log_events&lt;/code&gt;の&lt;code&gt;next_token&lt;/code&gt;オプションです。&lt;/p&gt;

&lt;h2 id=&#34;増分ログの取り方:879fe74068b1e39f8423ed492442144f&#34;&gt;増分ログの取り方&lt;/h2&gt;

&lt;p&gt;　&lt;code&gt;get_log_events&lt;/code&gt;のレスポンスには&lt;code&gt;next_forward_token&lt;/code&gt;と&lt;code&gt;next_backward_token&lt;/code&gt;が含まれています。これらは取得結果の次のページの位置を示しています。より新しいログの位置は名前的に&lt;code&gt;next_forward_token&lt;/code&gt;が保持しているっぽいです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.aws.amazon.com/sdkforruby/api/Aws/CloudWatchLogs/Client.html#get_log_events-instance_method&#34;&gt;Class: Aws::CloudWatchLogs::Client&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;resp.events #=&amp;gt; Array&lt;/p&gt;

&lt;p&gt;resp.events[0].timestamp #=&amp;gt; Integer&lt;/p&gt;

&lt;p&gt;resp.events[0].message #=&amp;gt; String&lt;/p&gt;

&lt;p&gt;resp.events[0].ingestion_time #=&amp;gt; Integer&lt;/p&gt;

&lt;p&gt;resp.next_forward_token #=&amp;gt; String&lt;/p&gt;

&lt;p&gt;resp.next_backward_token #=&amp;gt; String&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　そこで、このtokenを利用して&lt;code&gt;get_log_events&lt;/code&gt;を実行するように、スクリプトを変更します。tokenの値は、fluentdっぽくstateファイルを作り、そこに書き込んでおきます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# coding: utf-8

require &amp;#039;aws-sdk-core&amp;#039;
require &amp;#039;fileutils&amp;#039;

region = &amp;#039;ap-northeast-1&amp;#039;
log_group_name = &amp;#039;VPCFLowLog&amp;#039;
log_stream_name = &amp;#039;eni-xxxxxxxx-all&amp;#039;
@state_file = Dir.pwd + &#34;/&#34; + log_group_name + &#34;.&#34; + log_stream_name + &#34;.state&#34;

# トークンをstateファイルに書き込む
def write_token(token)
    File.open(@state_file,&#34;w&#34;) do |file|
        file.puts(token)
    end
end

# トークンをstateファイルから読み込む
def read_token
    if File.exist?(@state_file) then
        return File.read(@state_file).chomp
    else
        return 
    end
end

cloudwatchlogs = Aws::CloudWatchLogs::Client.new(region: region )

# cloudwatchlogs.get_log_eventsのオプションを定義
options = {
    log_group_name: log_group_name,
    log_stream_name: log_stream_name,
}

# もしstateファイルから前回のtokenが取得できたら、そのtokenをオプションに追加
if read_token != nil  then
    options[:next_token] = read_token
end

# ログを取得
resp = cloudwatchlogs.get_log_events(options)

# 取得したログからtokenを保存
write_token(resp.next_forward_token)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;動作確認:879fe74068b1e39f8423ed492442144f&#34;&gt;動作確認&lt;/h2&gt;

&lt;p&gt;　ElasticSearchに投入済みのデータは以下の通りです。19:25:47までのログが格納されています。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/06/001.png&#34; alt=&#34;投入済みデータ&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　&lt;code&gt;next_token&lt;/code&gt;をつけて&lt;code&gt;get_log_events&lt;/code&gt;したデータをElasticSearchに投入します。投入時のログは以下の通りです。19:28:40のデータ以降がElasticSearchに投入されていることがわかります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2015-06-14 19:38:36 +0900: &amp;gt; {&#34;@timestamp&#34;:&#34;2015-06-14 19:28:40&#34;,&#34;version&#34;:&#34;2&#34;,&#34;account-id&#34;:&#34;250369693989&#34;,&#34;interface-id&#34;:&#34;eni-f5a92c83&#34;,&#34;srcaddr&#34;:&#34;157.7.235.92&#34;,&#34;dstaddr&#34;:&#34;10.175.10.97&#34;,&#34;srcport&#34;:&#34;123&#34;,&#34;dstport&#34;:&#34;123&#34;,&#34;protocol&#34;:&#34;17&#34;,&#34;packets&#34;:&#34;1&#34;,&#34;bytes&#34;:&#34;76&#34;,&#34;start&#34;:&#34;1434277720&#34;,&#34;end&#34;:&#34;1434277760&#34;,&#34;action&#34;:&#34;ACCEPT&#34;,&#34;log-status&#34;:&#34;OK&#34;}
2015-06-14 19:38:36 +0900: &amp;lt; {&#34;_index&#34;:&#34;aws&#34;,&#34;_type&#34;:&#34;vpcflowlog&#34;,&#34;_id&#34;:&#34;AU3xpkmyyQj6bWWoL4TA&#34;,&#34;_version&#34;:1,&#34;created&#34;:true}
2015-06-14 19:38:36 +0900: POST http://localhost:9200/aws/vpcflowlog [status:201, request:0.004s, query:n/a]
2015-06-14 19:38:36 +0900: &amp;gt; {&#34;@timestamp&#34;:&#34;2015-06-14 19:28:40&#34;,&#34;version&#34;:&#34;2&#34;,&#34;account-id&#34;:&#34;250369693989&#34;,&#34;interface-id&#34;:&#34;eni-f5a92c83&#34;,&#34;srcaddr&#34;:&#34;10.175.10.97&#34;,&#34;dstaddr&#34;:&#34;157.7.235.92&#34;,&#34;srcport&#34;:&#34;123&#34;,&#34;dstport&#34;:&#34;123&#34;,&#34;protocol&#34;:&#34;17&#34;,&#34;packets&#34;:&#34;1&#34;,&#34;bytes&#34;:&#34;76&#34;,&#34;start&#34;:&#34;1434277720&#34;,&#34;end&#34;:&#34;1434277760&#34;,&#34;action&#34;:&#34;ACCEPT&#34;,&#34;log-status&#34;:&#34;OK&#34;}
2015-06-14 19:38:36 +0900: &amp;lt; {&#34;_index&#34;:&#34;aws&#34;,&#34;_type&#34;:&#34;vpcflowlog&#34;,&#34;_id&#34;:&#34;AU3xpkm4yQj6bWWoL4TB&#34;,&#34;_version&#34;:1,&#34;created&#34;:true}
2015-06-14 19:38:36 +0900: POST http://localhost:9200/aws/vpcflowlog [status:201, request:0.003s, query:n/a]
2015-06-14 19:38:36 +0900: &amp;gt; {&#34;@timestamp&#34;:&#34;2015-06-14 19:28:40&#34;,&#34;version&#34;:&#34;2&#34;,&#34;account-id&#34;:&#34;250369693989&#34;,&#34;interface-id&#34;:&#34;eni-f5a92c83&#34;,&#34;srcaddr&#34;:&#34;162.255.180.213&#34;,&#34;dstaddr&#34;:&#34;10.175.10.97&#34;,&#34;srcport&#34;:&#34;1982&#34;,&#34;dstport&#34;:&#34;445&#34;,&#34;protocol&#34;:&#34;6&#34;,&#34;packets&#34;:&#34;2&#34;,&#34;bytes&#34;:&#34;96&#34;,&#34;start&#34;:&#34;1434277720&#34;,&#34;end&#34;:&#34;1434277760&#34;,&#34;action&#34;:&#34;REJECT&#34;,&#34;log-status&#34;:&#34;OK&#34;}
2015-06-14 19:38:36 +0900: &amp;lt; {&#34;_index&#34;:&#34;aws&#34;,&#34;_type&#34;:&#34;vpcflowlog&#34;,&#34;_id&#34;:&#34;AU3xpkm9yQj6bWWoL4TC&#34;,&#34;_version&#34;:1,&#34;created&#34;:true}
2015-06-14 19:38:36 +0900: POST http://localhost:9200/aws/vpcflowlog [status:201, request:0.003s, query:n/a]
（中略）
2015-06-14 19:38:36 +0900: &amp;gt; {&#34;@timestamp&#34;:&#34;2015-06-14 19:35:22&#34;,&#34;version&#34;:&#34;2&#34;,&#34;account-id&#34;:&#34;250369693989&#34;,&#34;interface-id&#34;:&#34;eni-f5a92c83&#34;,&#34;srcaddr&#34;:&#34;10.175.10.97&#34;,&#34;dstaddr&#34;:&#34;46.17.98.184&#34;,&#34;srcport&#34;:&#34;22&#34;,&#34;dstport&#34;:&#34;27530&#34;,&#34;protocol&#34;:&#34;6&#34;,&#34;packets&#34;:&#34;1&#34;,&#34;bytes&#34;:&#34;48&#34;,&#34;start&#34;:&#34;1434278122&#34;,&#34;end&#34;:&#34;1434278181&#34;,&#34;action&#34;:&#34;ACCEPT&#34;,&#34;log-status&#34;:&#34;OK&#34;}
2015-06-14 19:38:36 +0900: &amp;lt; {&#34;_index&#34;:&#34;aws&#34;,&#34;_type&#34;:&#34;vpcflowlog&#34;,&#34;_id&#34;:&#34;AU3xpkoQyQj6bWWoL4TY&#34;,&#34;_version&#34;:1,&#34;created&#34;:true}
2015-06-14 19:38:36 +0900: POST http://localhost:9200/aws/vpcflowlog [status:201, request:0.002s, query:n/a]
2015-06-14 19:38:36 +0900: &amp;gt; {&#34;@timestamp&#34;:&#34;2015-06-14 19:36:55&#34;,&#34;version&#34;:&#34;2&#34;,&#34;account-id&#34;:&#34;250369693989&#34;,&#34;interface-id&#34;:&#34;eni-f5a92c83&#34;,&#34;srcaddr&#34;:&#34;199.203.59.117&#34;,&#34;dstaddr&#34;:&#34;10.175.10.97&#34;,&#34;srcport&#34;:&#34;26600&#34;,&#34;dstport&#34;:&#34;80&#34;,&#34;protocol&#34;:&#34;6&#34;,&#34;packets&#34;:&#34;1&#34;,&#34;bytes&#34;:&#34;48&#34;,&#34;start&#34;:&#34;1434278215&#34;,&#34;end&#34;:&#34;1434278241&#34;,&#34;action&#34;:&#34;REJECT&#34;,&#34;log-status&#34;:&#34;OK&#34;}
2015-06-14 19:38:36 +0900: &amp;lt; {&#34;_index&#34;:&#34;aws&#34;,&#34;_type&#34;:&#34;vpcflowlog&#34;,&#34;_id&#34;:&#34;AU3xpkoTyQj6bWWoL4TZ&#34;,&#34;_version&#34;:1,&#34;created&#34;:true}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　投入後のデータ一覧は以下の通りです。19:25:47以前のログが重複登録されることなく、19:25:47以降のログが増えました！！！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/06/002.png&#34; alt=&#34;投入済みデータ&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　それっぽく動いたスクリプトは以下の通りです。cronで回してみてみようと思います。&lt;/p&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# coding: utf-8

require &#34;json&#34;
require &amp;#039;aws-sdk-core&amp;#039;
require &amp;#039;elasticsearch&amp;#039;
require &amp;#039;fileutils&amp;#039;

region = &amp;#039;ap-northeast-1&amp;#039;
log_group_name = &amp;#039;VPCFLowLog&amp;#039;
log_stream_name = &amp;#039;eni-xxxxxxxx-all&amp;#039;
@state_file = Dir.pwd + &#34;/&#34; + log_group_name + &#34;.&#34; + log_stream_name + &#34;.state&#34;

# トークンをstateファイルに書き込む
def write_token(token)
    File.open(@state_file,&#34;w&#34;) do |file|
        file.puts(token)
    end
end

# トークンをstateファイルから読み込む
def read_token
    if File.exist?(@state_file) then
        return File.read(@state_file).chomp
    else
        return 
    end
end

cloudwatchlogs = Aws::CloudWatchLogs::Client.new(region: region )

# cloudwatchlogs.get_log_eventsのオプションを定義
options = {
    log_group_name: log_group_name,
    log_stream_name: log_stream_name,
}

# もしstateファイルから前回のtokenが取得できたら、そのtokenをオプションに追加
if read_token != nil  then
    options[:next_token] = read_token
end

# ログを取得
resp = cloudwatchlogs.get_log_events(options)

# 取得したログからtokenを保存
write_token(resp.next_forward_token)

hash = {}
message_elements = Array.new()

message_field = [
    &#34;version&#34;,
    &#34;account-id&#34;,
    &#34;interface-id&#34;,
    &#34;srcaddr&#34;,
    &#34;dstaddr&#34;,
    &#34;srcport&#34;,
    &#34;dstport&#34;,
    &#34;protocol&#34;,
    &#34;packets&#34;,
    &#34;bytes&#34;,
    &#34;start&#34;,
    &#34;end&#34;,
    &#34;action&#34;,
    &#34;log-status&#34;]

resp.events.each {|event|

    hash[&#34;@timestamp&#34;] = Time.at(event.timestamp/1000.0).strftime(&amp;#039;%Y-%m-%d %H:%M:%S&amp;#039;)
    message_elements = event.message.split(&#34; &#34;)
    message_elements.each.with_index(0)  {|element,i|
        hash[message_field[i]] = element
    }

    # BytesとPacketsをInteger型にすると、NODATAの時の-が型エラーになるので、捨てる
    if hash[&#34;log-status&#34;] != &#34;NODATA&#34; then
        client = Elasticsearch::Client.new(hosts: &#34;localhost:9200&#34;,log: true)
        client.index(index:&#34;aws&#34;, type:&#34;vpcflowlog&#34;, body:hash.to_json)
    end
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>aws-sdk-goでELB配下のインスタンスを取得する</title>
      <link>http://aimless.jp/blog/archives/2546</link>
      <pubDate>Sat, 11 Apr 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2546</guid>
      <description>&lt;p&gt;諸事情によりAWS製ツールをインストールできないWindows端末でAWSのAPIを叩く必要があり、手法を検討しました。あーだこーだと悩んだ結果、別の端末で作成したバイナリファイルを実行することを閃きました。こんな時のためのaws-sdk-goです。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &#34;fmt&#34;
    &#34;github.com/awslabs/aws-sdk-go/aws&#34;
    &#34;github.com/awslabs/aws-sdk-go/service/elb&#34;
    &#34;sort&#34;
    &#34;strings&#34;
)

func main() {
    accessKey := &#34;YOUR_ACCESS_KEY&#34;
    secretKey := &#34;YOUR_AECRET_KEY&#34;
    region := &#34;ap-northeast-1&#34;
    elbName := &#34;YOUR_ELB_NAME&#34;
    var inserviceInstances []string

    cred := aws.DetectCreds(accessKey, secretKey, &#34;&#34;)
    elbSvc := elb.New(&amp;aws.Config{Credentials: cred, Region: region})

    param := &amp;elb.DescribeInstanceHealthInput{
        LoadBalancerName: aws.String(elbName),
    }

    res, err := elbSvc.DescribeInstanceHealth(param)

    if err != nil {
        panic(err)
    }

    for i := range res.InstanceStates {
        result := *res.InstanceStates[i].InstanceID + &#34;:&#34; + *res.InstanceStates[i].State
        inserviceInstances = append(inserviceInstances, result)
    }

    sort.Strings(inserviceInstances)
    fmt.Print(strings.Join(inserviceInstances, &#34;,&#34;))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　このスクリプトを実行すると、対象ELB配下のインスタンスとその状態が表示されます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;go run main.go
i-xxxxxxxx:OutOfService,i-xxxxxxxx:OutOfService
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　コンパイルしたバイナリファイルを実行しても同じ結果になります。このバイナリを問題のWindows端末で実行すれば問題は解決です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;go build main.go

&amp;gt;main.exe
i-xxxxxxxx:OutOfService,i-xxxxxxxx:OutOfService
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Terraformでセキュリティグループを管理する</title>
      <link>http://aimless.jp/blog/archives/2481</link>
      <pubDate>Sun, 22 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2481</guid>
      <description>

&lt;p&gt;Terraformによるセキュリティグループ管理に関するメモ。&lt;/p&gt;

&lt;p&gt;　Terraformのバージョンアップにより、タグ付けやegressのルールが使えるようになったので、マネジメントコンソールと同じ事ができるようになっています。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;version&lt;/th&gt;
&lt;th&gt;IMPROVEMENTS&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0.3.7 (February 19, 2015)&lt;/td&gt;
&lt;td&gt;provider/aws: Security group support egress rules. [GH-856]&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0.3.1 (October 21, 2014)&lt;/td&gt;
&lt;td&gt;providers/aws: Support tags for security groups.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;ファイル構成:29a47d36f0cb88ad8f2feca5cd4e2d83&#34;&gt;ファイル構成&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;$ ls                                               
var.tf　　  　terraform.tfvars        web-sg.tf
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　tfファイルで利用する変数を定義するためのファイル&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  cat var.tf                                      
variable &#34;access_key&#34; {}
variable &#34;secret_key&#34; {}
variable &#34;region&#34; {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　tfファイルで利用する変数に値を代入するためのファイル&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat terraform.tfvars 
#-------------------------------------$
# credential$
#-------------------------------------$

access_key = &#34;YOUR_ACCESS_KEY&#34;
secret_key = &#34;YOUR_SECRET_KEY&#34;

#-------------------------------------
# region
#-------------------------------------
#
region = &#34;ap-northeast-1&#34;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　実際の処理を書いたファイル。WEBサーバ向けにHTTPを全許可するセキュリティグループを作ります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat web-sg.tf 
provider &#34;aws&#34; {
    access_key = &#34;${var.access_key}&#34;
    secret_key = &#34;${var.secret_key}&#34;
    region = &#34;${var.region}&#34;
}

resource &#34;aws_security_group&#34; &#34;web-server&#34; {
  name = &#34;web-server-sg&#34;
  description = &#34;Allow traffic of webserver&#34;

  ingress {
      from_port = 80 
      to_port = 80
      protocol = &#34;tcp&#34;
      cidr_blocks = [&#34;0.0.0.0/0&#34;]
  }
  vpc_id = &#34;vpc-d01806b2&#34;
  tags {
    Name = &#34;web-server&#34;
    Made = &#34;terraform&#34;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;セキュリティグループの作成:29a47d36f0cb88ad8f2feca5cd4e2d83&#34;&gt;セキュリティグループの作成&lt;/h2&gt;

&lt;p&gt;まずは&lt;code&gt;terraform plan&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ terraform plan
Refreshing Terraform state prior to plan...


The Terraform execution plan has been generated and is shown below.
Resources are shown in alphabetical order for quick scanning. Green resources
will be created (or destroyed and then created if an existing resource
exists), yellow resources are being changed in-place, and red resources
will be destroyed.

Note: You didn&amp;#039;t specify an &#34;-out&#34; parameter to save this plan, so when
&#34;apply&#34; is called, Terraform can&amp;#039;t guarantee this is what will execute.

+ aws_security_group.web-server
    description:                          &#34;&#34; =&amp;gt; &#34;Allow traffic of webserver&#34;
    egress.#:                             &#34;&#34; =&amp;gt; &#34;&amp;lt;computed&amp;gt;&#34;
    ingress.#:                            &#34;&#34; =&amp;gt; &#34;1&#34;
    ingress.2603706321.cidr_blocks.#:     &#34;&#34; =&amp;gt; &#34;1&#34;
    ingress.2603706321.cidr_blocks.0:     &#34;&#34; =&amp;gt; &#34;0.0.0.0/0&#34;
    ingress.2603706321.from_port:         &#34;&#34; =&amp;gt; &#34;80&#34;
    ingress.2603706321.protocol:          &#34;&#34; =&amp;gt; &#34;tcp&#34;
    ingress.2603706321.security_groups.#: &#34;&#34; =&amp;gt; &#34;0&#34;
    ingress.2603706321.self:              &#34;&#34; =&amp;gt; &#34;0&#34;
    ingress.2603706321.to_port:           &#34;&#34; =&amp;gt; &#34;80&#34;
    name:                                 &#34;&#34; =&amp;gt; &#34;web-server-sg&#34;
    owner_id:                             &#34;&#34; =&amp;gt; &#34;&amp;lt;computed&amp;gt;&#34;
    tags.#:                               &#34;&#34; =&amp;gt; &#34;2&#34;
    tags.Made:                            &#34;&#34; =&amp;gt; &#34;terraform&#34;
    tags.Name:                            &#34;&#34; =&amp;gt; &#34;web-server&#34;
    vpc_id:                               &#34;&#34; =&amp;gt; &#34;vpc-d01806b2&#34;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　問題なさそうなので&lt;code&gt;terraform apply&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ terraform apply
aws_security_group.web-server: Creating...
  description:                          &#34;&#34; =&amp;gt; &#34;Allow traffic of webserver&#34;
  egress.#:                             &#34;&#34; =&amp;gt; &#34;&amp;lt;computed&amp;gt;&#34;
  ingress.#:                            &#34;&#34; =&amp;gt; &#34;1&#34;
  ingress.2603706321.cidr_blocks.#:     &#34;&#34; =&amp;gt; &#34;1&#34;
  ingress.2603706321.cidr_blocks.0:     &#34;&#34; =&amp;gt; &#34;0.0.0.0/0&#34;
  ingress.2603706321.from_port:         &#34;&#34; =&amp;gt; &#34;80&#34;
  ingress.2603706321.protocol:          &#34;&#34; =&amp;gt; &#34;tcp&#34;
  ingress.2603706321.security_groups.#: &#34;&#34; =&amp;gt; &#34;0&#34;
  ingress.2603706321.self:              &#34;&#34; =&amp;gt; &#34;0&#34;
  ingress.2603706321.to_port:           &#34;&#34; =&amp;gt; &#34;80&#34;
  name:                                 &#34;&#34; =&amp;gt; &#34;web-server-sg&#34;
  owner_id:                             &#34;&#34; =&amp;gt; &#34;&amp;lt;computed&amp;gt;&#34;
  tags.#:                               &#34;&#34; =&amp;gt; &#34;2&#34;
  tags.Made:                            &#34;&#34; =&amp;gt; &#34;terraform&#34;
  tags.Name:                            &#34;&#34; =&amp;gt; &#34;web-server&#34;
  vpc_id:                               &#34;&#34; =&amp;gt; &#34;vpc-d01806b2&#34;
aws_security_group.web-server: Creation complete

Apply complete! Resources: 1 added, 0 changed, 0 destroyed.

The state of your infrastructure has been saved to the path
below. This state is required to modify and destroy your
infrastructure, so keep it safe. To inspect the complete state
use the `terraform show` command.

State path: terraform.tfstate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　&lt;code&gt;1 added&lt;/code&gt;となっています。&lt;code&gt;terraform show&lt;/code&gt;で今の状態を確認します。sg-8a53d6efができました。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ terraform show                                                                         
aws_security_group.web-server:
  id = sg-8a53d6ef
  description = Allow traffic of webserver
  egress.# = 1
  egress.1965070075.cidr_blocks.# = 1
  egress.1965070075.cidr_blocks.0 = 0.0.0.0/0
  egress.1965070075.from_port = 0
  egress.1965070075.protocol = -1
  egress.1965070075.security_groups.# = 0
  egress.1965070075.self = false
  egress.1965070075.to_port = 0
  ingress.# = 1
  ingress.2603706321.cidr_blocks.# = 1
  ingress.2603706321.cidr_blocks.0 = 0.0.0.0/0
  ingress.2603706321.from_port = 80
  ingress.2603706321.protocol = tcp
  ingress.2603706321.security_groups.# = 0
  ingress.2603706321.self = false
  ingress.2603706321.to_port = 80
  name = web-server-sg
  owner_id = MY_AWS_ACCOUNT_NUMBER
  tags.# = 2
  tags.Made = terraform
  tags.Name = web-server
  vpc_id = vpc-d01806b2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　マネジメントコンソールでも、Terraformの指示通りのセキュリティグループが作成されたことが確認できます。&lt;/p&gt;

&lt;p&gt;　&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/03/2015-03-22-01.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ルールの追加-inbound:29a47d36f0cb88ad8f2feca5cd4e2d83&#34;&gt;ルールの追加（Inbound）&lt;/h2&gt;

&lt;p&gt;　inboundにHTTPSを追加してみましょう。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat web-sg.tf 
provider &#34;aws&#34; {
    access_key = &#34;${var.access_key}&#34;
    secret_key = &#34;${var.secret_key}&#34;
    region = &#34;${var.region}&#34;
}

resource &#34;aws_security_group&#34; &#34;web-server&#34; {
  name = &#34;web-server-sg&#34;
  description = &#34;Allow traffic of webserver&#34;

  ingress {
      from_port = 80 
      to_port = 80
      protocol = &#34;tcp&#34;
      cidr_blocks = [&#34;0.0.0.0/0&#34;]
  }
  ingress {
      from_port = 443
      to_port = 443
      protocol = &#34;tcp&#34;
      cidr_blocks = [&#34;0.0.0.0/0&#34;]
  }
  vpc_id = &#34;vpc-d01806b2&#34;
  tags {
    Name = &#34;web-server&#34;
    Made = &#34;terraform&#34;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　tfファイルを編集後、&lt;code&gt;terraform plan&lt;/code&gt;からの&lt;code&gt;terraform apply&lt;/code&gt;、&lt;code&gt;terraform show&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ terraform plan
Refreshing Terraform state prior to plan...

aws_security_group.web-server: Refreshing state... (ID: sg-8a53d6ef)

The Terraform execution plan has been generated and is shown below.
Resources are shown in alphabetical order for quick scanning. Green resources
will be created (or destroyed and then created if an existing resource
exists), yellow resources are being changed in-place, and red resources
will be destroyed.

Note: You didn&amp;#039;t specify an &#34;-out&#34; parameter to save this plan, so when
&#34;apply&#34; is called, Terraform can&amp;#039;t guarantee this is what will execute.

~ aws_security_group.web-server
    ingress.#:                            &#34;1&#34; =&amp;gt; &#34;2&#34;
    ingress.2603706321.cidr_blocks.#:     &#34;1&#34; =&amp;gt; &#34;1&#34;
    ingress.2603706321.cidr_blocks.0:     &#34;0.0.0.0/0&#34; =&amp;gt; &#34;0.0.0.0/0&#34;
    ingress.2603706321.from_port:         &#34;80&#34; =&amp;gt; &#34;80&#34;
    ingress.2603706321.protocol:          &#34;tcp&#34; =&amp;gt; &#34;tcp&#34;
    ingress.2603706321.security_groups.#: &#34;0&#34; =&amp;gt; &#34;0&#34;
    ingress.2603706321.self:              &#34;0&#34; =&amp;gt; &#34;0&#34;
    ingress.2603706321.to_port:           &#34;80&#34; =&amp;gt; &#34;80&#34;
    ingress.4089093546.cidr_blocks.#:     &#34;0&#34; =&amp;gt; &#34;1&#34;
    ingress.4089093546.cidr_blocks.0:     &#34;&#34; =&amp;gt; &#34;0.0.0.0/0&#34;
    ingress.4089093546.from_port:         &#34;&#34; =&amp;gt; &#34;443&#34;
    ingress.4089093546.protocol:          &#34;&#34; =&amp;gt; &#34;tcp&#34;
    ingress.4089093546.security_groups.#: &#34;0&#34; =&amp;gt; &#34;0&#34;
    ingress.4089093546.self:              &#34;&#34; =&amp;gt; &#34;0&#34;
    ingress.4089093546.to_port:           &#34;&#34; =&amp;gt; &#34;443&#34;


$ 
$ terraform apply
aws_security_group.web-server: Refreshing state... (ID: sg-8a53d6ef)
aws_security_group.web-server: Modifying...
  ingress.#:                            &#34;1&#34; =&amp;gt; &#34;2&#34;
  ingress.2603706321.cidr_blocks.#:     &#34;1&#34; =&amp;gt; &#34;1&#34;
  ingress.2603706321.cidr_blocks.0:     &#34;0.0.0.0/0&#34; =&amp;gt; &#34;0.0.0.0/0&#34;
  ingress.2603706321.from_port:         &#34;80&#34; =&amp;gt; &#34;80&#34;
  ingress.2603706321.protocol:          &#34;tcp&#34; =&amp;gt; &#34;tcp&#34;
  ingress.2603706321.security_groups.#: &#34;0&#34; =&amp;gt; &#34;0&#34;
  ingress.2603706321.self:              &#34;0&#34; =&amp;gt; &#34;0&#34;
  ingress.2603706321.to_port:           &#34;80&#34; =&amp;gt; &#34;80&#34;
  ingress.4089093546.cidr_blocks.#:     &#34;0&#34; =&amp;gt; &#34;1&#34;
  ingress.4089093546.cidr_blocks.0:     &#34;&#34; =&amp;gt; &#34;0.0.0.0/0&#34;
  ingress.4089093546.from_port:         &#34;&#34; =&amp;gt; &#34;443&#34;
  ingress.4089093546.protocol:          &#34;&#34; =&amp;gt; &#34;tcp&#34;
  ingress.4089093546.security_groups.#: &#34;0&#34; =&amp;gt; &#34;0&#34;
  ingress.4089093546.self:              &#34;&#34; =&amp;gt; &#34;0&#34;
  ingress.4089093546.to_port:           &#34;&#34; =&amp;gt; &#34;443&#34;
aws_security_group.web-server: Modifications complete

Apply complete! Resources: 0 added, 1 changed, 0 destroyed.

The state of your infrastructure has been saved to the path
below. This state is required to modify and destroy your
infrastructure, so keep it safe. To inspect the complete state
use the `terraform show` command.

State path: terraform.tfstate
$ 
$ terraform show
aws_security_group.web-server:
  id = sg-8a53d6ef
  description = Allow traffic of webserver
  egress.# = 1
  egress.1965070075.cidr_blocks.# = 1
  egress.1965070075.cidr_blocks.0 = 0.0.0.0/0
  egress.1965070075.from_port = 0
  egress.1965070075.protocol = -1
  egress.1965070075.security_groups.# = 0
  egress.1965070075.self = false
  egress.1965070075.to_port = 0
  ingress.# = 2
  ingress.2603706321.cidr_blocks.# = 1
  ingress.2603706321.cidr_blocks.0 = 0.0.0.0/0
  ingress.2603706321.from_port = 80
  ingress.2603706321.protocol = tcp
  ingress.2603706321.security_groups.# = 0
  ingress.2603706321.self = false
  ingress.2603706321.to_port = 80
  ingress.4089093546.cidr_blocks.# = 1
  ingress.4089093546.cidr_blocks.0 = 0.0.0.0/0
  ingress.4089093546.from_port = 443
  ingress.4089093546.protocol = tcp
  ingress.4089093546.security_groups.# = 0
  ingress.4089093546.self = false
  ingress.4089093546.to_port = 443
  name = web-server-sg
  owner_id = MY_AWS_ACCOUNT_NUMBER
  tags.# = 2
  tags.Made = terraform
  tags.Name = web-server
  vpc_id = vpc-d01806b2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　&lt;code&gt;1 changed&lt;/code&gt;となっています。既存のリソースに変更が発生しました。マネジメントコンソール上で確認すると、inboundにHTTPSが増えています。&lt;/p&gt;

&lt;p&gt;　&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/03/2015-03-22-02.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ルールの追加-outbound:29a47d36f0cb88ad8f2feca5cd4e2d83&#34;&gt;ルールの追加（Outbound）&lt;/h2&gt;

&lt;p&gt;　新たにサポートされたegressも使ってみます。sg-2da11148がNATインスタンスに適用されている体で、sg-2da11148向けのOutbound全通信を許可するルールを追加します。&lt;/p&gt;

&lt;p&gt;　許可対象にセキュリティグループを利用する時は、&lt;code&gt;cidr_blocks&lt;/code&gt;ではなく&lt;code&gt;security_groups&lt;/code&gt;を利用します。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ cat web-sg.tf 
provider &#34;aws&#34; {
    access_key = &#34;${var.access_key}&#34;
    secret_key = &#34;${var.secret_key}&#34;
    region = &#34;${var.region}&#34;
}

resource &#34;aws_security_group&#34; &#34;web-server&#34; {
  name = &#34;web-server-sg&#34;
  description = &#34;Allow traffic of webserver&#34;

  ingress {
      from_port = 80 
      to_port = 80
      protocol = &#34;tcp&#34;
      cidr_blocks = [&#34;0.0.0.0/0&#34;]
  }
  ingress {
      from_port = 443
      to_port = 443
      protocol = &#34;tcp&#34;
      cidr_blocks = [&#34;0.0.0.0/0&#34;]
  }
  egress {
      from_port = 0
      to_port = 65535
      protocol = &#34;-1&#34;
      security_groups = [&#34;sg-2da11148&#34;]
  }
  vpc_id = &#34;vpc-d01806b2&#34;
  tags {
    Name = &#34;web-server&#34;
    Made = &#34;terraform&#34;
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　tfファイルを編集後、&lt;code&gt;terraform plan&lt;/code&gt;からの&lt;code&gt;terraform apply&lt;/code&gt;、&lt;code&gt;terraform show&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$  terraform plan
Refreshing Terraform state prior to plan...

aws_security_group.web-server: Refreshing state... (ID: sg-8a53d6ef)

The Terraform execution plan has been generated and is shown below.
Resources are shown in alphabetical order for quick scanning. Green resources
will be created (or destroyed and then created if an existing resource
exists), yellow resources are being changed in-place, and red resources
will be destroyed.

Note: You didn&amp;#039;t specify an &#34;-out&#34; parameter to save this plan, so when
&#34;apply&#34; is called, Terraform can&amp;#039;t guarantee this is what will execute.

~ aws_security_group.web-server
    egress.2221449193.cidr_blocks.#:              &#34;0&#34; =&amp;gt; &#34;0&#34;
    egress.2221449193.from_port:                  &#34;&#34; =&amp;gt; &#34;0&#34;
    egress.2221449193.protocol:                   &#34;&#34; =&amp;gt; &#34;-1&#34;
    egress.2221449193.security_groups.#:          &#34;0&#34; =&amp;gt; &#34;1&#34;
    egress.2221449193.security_groups.1429001686: &#34;&#34; =&amp;gt; &#34;sg-2da11148&#34;
    egress.2221449193.self:                       &#34;&#34; =&amp;gt; &#34;0&#34;
    egress.2221449193.to_port:                    &#34;&#34; =&amp;gt; &#34;65535&#34;


$ terraform apply
aws_security_group.web-server: Refreshing state... (ID: sg-8a53d6ef)
aws_security_group.web-server: Modifying...
  egress.2221449193.cidr_blocks.#:              &#34;0&#34; =&amp;gt; &#34;0&#34;
  egress.2221449193.from_port:                  &#34;&#34; =&amp;gt; &#34;0&#34;
  egress.2221449193.protocol:                   &#34;&#34; =&amp;gt; &#34;-1&#34;
  egress.2221449193.security_groups.#:          &#34;0&#34; =&amp;gt; &#34;1&#34;
  egress.2221449193.security_groups.1429001686: &#34;&#34; =&amp;gt; &#34;sg-2da11148&#34;
  egress.2221449193.self:                       &#34;&#34; =&amp;gt; &#34;0&#34;
  egress.2221449193.to_port:                    &#34;&#34; =&amp;gt; &#34;65535&#34;
aws_security_group.web-server: Modifications complete

Apply complete! Resources: 0 added, 1 changed, 0 destroyed.

The state of your infrastructure has been saved to the path
below. This state is required to modify and destroy your
infrastructure, so keep it safe. To inspect the complete state
use the `terraform show` command.

State path: terraform.tfstate
$ terraform show
aws_security_group.web-server:
  id = sg-8a53d6ef
  description = Allow traffic of webserver
  egress.# = 1
  egress.2221449193.cidr_blocks.# = 0
  egress.2221449193.from_port = 0
  egress.2221449193.protocol = -1
  egress.2221449193.security_groups.# = 1
  egress.2221449193.security_groups.1429001686 = sg-2da11148
  egress.2221449193.self = false
  egress.2221449193.to_port = 65535
  ingress.# = 2
  ingress.2603706321.cidr_blocks.# = 1
  ingress.2603706321.cidr_blocks.0 = 0.0.0.0/0
  ingress.2603706321.from_port = 80
  ingress.2603706321.protocol = tcp
  ingress.2603706321.security_groups.# = 0
  ingress.2603706321.self = false
  ingress.2603706321.to_port = 80
  ingress.4089093546.cidr_blocks.# = 1
  ingress.4089093546.cidr_blocks.0 = 0.0.0.0/0
  ingress.4089093546.from_port = 443
  ingress.4089093546.protocol = tcp
  ingress.4089093546.security_groups.# = 0
  ingress.4089093546.self = false
  ingress.4089093546.to_port = 443
  name = web-server-sg
  owner_id = MY_AWS_ACCOUNT_NUMBER
  tags.# = 2
  tags.Made = terraform
  tags.Name = web-server
  vpc_id = vpc-d01806b2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　1 changed　となっています。既存のリソースに変更が発生しています。マネジメントコンソール上で確認すると、outboundにsg-2da11148向けのALL Trafficが増えています。&lt;/p&gt;

&lt;p&gt;　&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/03/2015-03-22-03.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Terraformのroot_block_deviceを使う</title>
      <link>http://aimless.jp/blog/archives/2439</link>
      <pubDate>Mon, 09 Mar 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2439</guid>
      <description>

&lt;p&gt;Terraformのroot_block_deviceで躓いたのでメモ。&lt;/p&gt;

&lt;h2 id=&#34;やりたいこと:bf37395249d323f0a481b0db49ec8488&#34;&gt;やりたいこと&lt;/h2&gt;

&lt;p&gt;　Terraformを利用して、10Gのルートデバイスと20Gのブロックデバイスを持ったt2.microのインスタンスを起動する&lt;/p&gt;

&lt;h2 id=&#34;やったこと:bf37395249d323f0a481b0db49ec8488&#34;&gt;やったこと&lt;/h2&gt;

&lt;p&gt;　クレデンシャルを記載したtfファイルを作成する&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kongou-ae/a993635d9521162fe6b4.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;　リソース作成の処理を記載したtfファイルを作成する&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kongou-ae/ccb5844778b3d1880f11.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;　処理で利用する変数ファイルをまとめて定義するtfファイルを作成する&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kongou-ae/effeb26ef16f22c18386.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;　terraform実行時に渡す変数をまとめたtfファイルを作成する&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kongou-ae/4bbc36de4c64ea1c4fe0.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;　terraformする。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kongou-ae/4b8f40fe3a91b6a288c1.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;失敗談:bf37395249d323f0a481b0db49ec8488&#34;&gt;失敗談&lt;/h2&gt;

&lt;p&gt;　ebs_root_device_nameの値をAMIのルートデバイス名と異なる値にしたところ、root_block_deviceのパラメータが追加のブロックデバイスとして判断されてしまった。&lt;/p&gt;

&lt;p&gt;　たとえば、Amazon Linuxに対してebs_root_device_nameを指定しないと、デフォルト値である/dev/sda1が利用されてしまい、ルートデバイスはAMIのデフォルト、そのほかにブロックデバイスが追加で2個EBSが作成されてしまう。&lt;/p&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;h3 id=&#34;失敗の事例:bf37395249d323f0a481b0db49ec8488&#34;&gt;失敗の事例&lt;/h3&gt;

&lt;p&gt;　ebs_root_device_nameを指定せずにterraformしたログは以下の通り。terraform plan ではルートデバイス1個、ブロックデバイス1個となっているが、terraform applyしてみると、block_device.# = 2になっている。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kongou-ae/7ae35971fa5a2c8a17e0.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>業務時間外にEC2を停止する</title>
      <link>http://aimless.jp/blog/archives/2429</link>
      <pubDate>Thu, 26 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2429</guid>
      <description>&lt;p&gt;AWS上に複数人が利用する開発用サーバを立てました。24時間365日稼働させる必要はありませんが、手作業で起動・停止を行うのも馬鹿げています。&lt;/p&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;p&gt;　そこで、業務時間外に対象インスタンスを停止し、始業前に対象インスタンスを開始するスクリプトを書いて、NATインスタンス上のcronで実行してみました。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kongou-ae/039ef45a992393e00418.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;　ちゃんと動いていますが、以下の様な点を修正する必要がありますね。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;AWS CLIの実行結果が標準出力となり、ec2-userにメールが届いてしまう&lt;/li&gt;
&lt;li&gt;万が一起動に失敗した場合、他のメンバーに迷惑がかかるので、メール通知したい。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>セキュリティグループの詳細をCSV形式で出力する</title>
      <link>http://aimless.jp/blog/archives/2418</link>
      <pubDate>Mon, 23 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2418</guid>
      <description>&lt;p&gt;セキュリティグループにルールを追加すればするほどマネジメントコンソールでの一覧性が下がるので、全てのルールをCSV形式でエクスポートするコマンドを作ってみました。aws-to-csvです。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/kongou-ae/aws-to-csv&#34;&gt;kongou-ae/aws-to-csv&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ ./a2csv securityGroups -r ap-northeast-1 -p private
GroupID,Direction,Type,Protocol,Port Range,IP Range
sg-b6822ed3,inbound,ALL ICMP,ICMP(1),ALL,sg-a9822ecc
sg-b6822ed3,outbound,ALL Traffic,ALL,ALL,0.0.0.0/0
sg-6ad86e0f,inbound,SSH(22),TCP(6),22,0.0.0.0/0
sg-6ad86e0f,outbound,ALL Traffic,ALL,ALL,0.0.0.0/0
sg-f07cdd95,inbound,RDP(3389),TCP(6),3389,192.168.11.1/32
sg-f07cdd95,outbound,ALL Traffic,ALL,ALL,0.0.0.0/0
sg-a9822ecc,inbound,ALL Traffic,ALL,ALL,192.168.11.1/32
sg-a9822ecc,outbound,ALL ICMP,ICMP(1),ALL,sg-b6822ed3
sg-aa2686cf,inbound,Custom Rrotocol Rule,HOPOPT(0),ALL,sg-6ad86e0f
sg-aa2686cf,inbound,SSH(22),TCP(6),22,192.168.11.1/32
sg-aa2686cf,outbound,ALL Traffic,ALL,ALL,0.0.0.0/0
sg-b10aecd4,inbound,SSH(22),TCP(6),22,0.0.0.0/0
sg-b10aecd4,outbound,ALL Traffic,ALL,ALL,0.0.0.0/0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　セキュリティグループは、APIのレスポンスをそのままCSV形式でエクスポートすると、出力内容がマネジメントコンソールの表示と大きく異なってしまい可読性が低くなります。そこで、APIのレスポンスをあの手この手で細工してからCSV形式で出力するようにしています。&lt;/p&gt;

&lt;p&gt;　今までpythonで遊んでいましたが、今回は、クロスコンパイルにあこがれてgolangを使ってみました。これはすごいですね。VPSでwindows用にコンパイルしたa2csv.exeが、会社のwindows端末でそのまま動く。pythonで書いたコードを使うために、会社のPCにpythonをインストールしていたのが馬鹿みたいです。。。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Amazon LinuxにLodgeをインストールした</title>
      <link>http://aimless.jp/blog/archives/2408</link>
      <pubDate>Thu, 19 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2408</guid>
      <description>&lt;p&gt;Amazon Linuxにナレッジ/ノウハウ情報共有サービスのOSS「Lodge」をインストールしたので手順をメモしておきます。取りあえず動かすことが目的です。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kongou-ae/2df0e742ff0590781189.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;　ブラウザから「ec2-xxx-xxx-xxx-xxx.ap-northeast-1.compute.amazonaws.com:3000」にアクセスしてログイン画面が出れば成功です。TCP/3000をセキュリティグループで許可することを忘れずに。&lt;/p&gt;

&lt;p&gt;　&lt;/p&gt;

&lt;p&gt;　また、TCP/3000でのアクセスは不便だったので、前段にNginx等のリバースプロキシを置いてTCP/80でアクセスできるようにしました。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AWS上のオンデマンドなUTM製品を比較する</title>
      <link>http://aimless.jp/blog/archives/2399</link>
      <pubDate>Mon, 16 Feb 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2399</guid>
      <description>&lt;p&gt;イマイチ使いどころが見つけられないAWS上のUTM製品について、オンデマンド版（ライセンスこみで使えるAMI）の費用を比較しました。&lt;/p&gt;

&lt;p&gt;　なお、AWS上には、Barracuda NG FirewallやPaloalto VM-Seriesもあるのですが、これらはオンデマンド版が存在せずBYOL版のみのため、記載していません。オンデマンド版があれば、評価しやすいのに。。。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;インスタンスタイプ&lt;/th&gt;
&lt;th&gt;FortiGate-VM&lt;/th&gt;
&lt;th&gt;CheckPoint VA&lt;/th&gt;
&lt;th&gt;sophos-UTM 9&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;t1.micro&lt;/td&gt;
&lt;td&gt;&amp;#8211;&lt;/td&gt;
&lt;td&gt;&amp;#8211;&lt;/td&gt;
&lt;td&gt;$0.02/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;t1.small&lt;/td&gt;
&lt;td&gt;&amp;#8211;&lt;/td&gt;
&lt;td&gt;&amp;#8211;&lt;/td&gt;
&lt;td&gt;$0.264/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m3.medium&lt;/td&gt;
&lt;td&gt;$0.37/hr&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;$0.42/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m3.large&lt;/td&gt;
&lt;td&gt;$0.95/hr&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;$0.84/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m3.xlarge&lt;/td&gt;
&lt;td&gt;$2.13/hr&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;$1.68/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;m3.2xlarge&lt;/td&gt;
&lt;td&gt;$4.49/hr&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;$3.36/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c3.large&lt;/td&gt;
&lt;td&gt;$0.835/hr&lt;/td&gt;
&lt;td&gt;$1.815/hr&lt;/td&gt;
&lt;td&gt;$0.525/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c3.xlarge&lt;/td&gt;
&lt;td&gt;$1.87/hr&lt;/td&gt;
&lt;td&gt;$2.80/hr&lt;/td&gt;
&lt;td&gt;$1.05/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c3.2xlarge&lt;/td&gt;
&lt;td&gt;$3.95/hr&lt;/td&gt;
&lt;td&gt;$4.86/hr&lt;/td&gt;
&lt;td&gt;$2.10/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c3.4xlarge&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;$6.483/hr&lt;/td&gt;
&lt;td&gt;$4.20/hr&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;c3.8xlarge&lt;/td&gt;
&lt;td&gt;–&lt;/td&gt;
&lt;td&gt;$8.688/hr&lt;/td&gt;
&lt;td&gt;$8.40/hr&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>AWSにFortiGateをデプロイしてみた（NATとFWポリシー編）</title>
      <link>http://aimless.jp/blog/archives/2358</link>
      <pubDate>Sat, 24 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2358</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://aimless.jp/blog/blog/archives/2317&#34;&gt;AWSにFortiGateをデプロイしてみた（ネットワーク設定編）&lt;/a&gt;の続きです。AWS上に設置したFortiGateでNATとFWポリシーを試します。&lt;/p&gt;

&lt;h2 id=&#34;vpc環境:ec17bdc7c38ff198df2edaa2953430eb&#34;&gt;VPC環境&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;FortiGate-VM&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;項目&lt;/th&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;プライベートIP&lt;/th&gt;
&lt;th&gt;EIP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ENI(Exernal)&lt;/td&gt;
&lt;td&gt;eni-921a6ecb&lt;/td&gt;
&lt;td&gt;10&amp;#46;175.1.195&lt;/td&gt;
&lt;td&gt;54&amp;#46;65.151.103&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ENI(internal)&lt;/td&gt;
&lt;td&gt;eni-6304703a&lt;/td&gt;
&lt;td&gt;10&amp;#46;175.2.195&lt;/td&gt;
&lt;td&gt;&amp;#8211;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;CIDR&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;項目&lt;/th&gt;
&lt;th&gt;値&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;VPC CIDR&lt;/td&gt;
&lt;td&gt;10&amp;#46;175.0.0/16&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;external_subnet&lt;/td&gt;
&lt;td&gt;10&amp;#46;175.1.0/24&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;internal_subnet&lt;/td&gt;
&lt;td&gt;10&amp;#46;175.2.0/24&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;external_subnetのroute-table&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Destination&lt;/th&gt;
&lt;th&gt;Target&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&amp;#46;175.0.0/16&lt;/td&gt;
&lt;td&gt;local&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0&amp;#46;0.0.0&lt;/td&gt;
&lt;td&gt;IGW&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;internal_subnetのroute-table&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Destination&lt;/th&gt;
&lt;th&gt;Target&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;10&amp;#46;175.0.0/16&lt;/td&gt;
&lt;td&gt;local&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;0&amp;#46;0.0.0/0&lt;/td&gt;
&lt;td&gt;eni-6304703a&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　internal_subnetに配置されたインスタンスとインターネットとの通信が、FortiGate-VMを経由するよう、デフォルトルートをFortiGate-VMのinternal側ENIに向けます。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;動作確認用インスタンス&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;　internal_subnetにAmazon_linuxを設置します。IPアドレスは10.175.2.152です。&lt;/p&gt;

&lt;h2 id=&#34;事前準備:ec17bdc7c38ff198df2edaa2953430eb&#34;&gt;事前準備&lt;/h2&gt;

&lt;p&gt;　FortiGate-VMの2つのENIで「Source/dest. check」をfalseにします。なお、インスタンスを右クリックしてSource/dest. checkをfalseにしても、2本目のENIはenableのままでした。Source/dest. checkは、インスタンスではなくENIに対して実施しましょう。&lt;/p&gt;

&lt;h2 id=&#34;ポートフォワード:ec17bdc7c38ff198df2edaa2953430eb&#34;&gt;ポートフォワード&lt;/h2&gt;

&lt;p&gt;　まずはポートフォワードからです。internalに設置されているEC2:10.175.2.152のSSHを、EIP:54.65.151.103の11022で外部公開します。&lt;/p&gt;

&lt;p&gt;　クライアントとサーバだけに注目した通信要件は、「54.65.151.103の11022」を「10.175.2.152の22」にポートフォワードするになりますので、以下の様に設定したのですが、通信できずドツボにはまりました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/01/aws-fg-1.png&#34; alt=&#34;enter image description here&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　正しい通信要件は、「EIP:54.65.151.103の11022」をAWSが変換した「10.175.1.195の11022」を、ForiGateが「10.175.2.152の22」にポートフォワードするになりますので、以下の様に設定する必要があります。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/01/aws-fg-2.png&#34; alt=&#34;enter image description here&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;スタティックnat:ec17bdc7c38ff198df2edaa2953430eb&#34;&gt;スタティックNAT&lt;/h2&gt;

&lt;p&gt;　次はスタティックNATです。FortiGate-VMとは異なるグローバルIPアドレスでEC2を外部公開します。&lt;/p&gt;

&lt;p&gt;　external側のENIに10.175.1.0/24のIPアドレス（10.175.1.194）を追加します。そしてEIPをもう一つ取得し、10.175.1.194に割り当てます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/01/aws-fg-3.png&#34; alt=&#34;enter image description here&#34; /&gt;&lt;/p&gt;

&lt;p&gt;これにより、FortiGate-VMのパラメータは以下になります。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FortiGate-VM&lt;/strong&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;項目&lt;/th&gt;
&lt;th&gt;ID&lt;/th&gt;
&lt;th&gt;プライベートIP&lt;/th&gt;
&lt;th&gt;EIP&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ENI(Exernal)&lt;/td&gt;
&lt;td&gt;eni-921a6ecb&lt;/td&gt;
&lt;td&gt;10&amp;#46;175.1.195&lt;/td&gt;
&lt;td&gt;54&amp;#46;65.151.103&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ENI(Exernal)&lt;/td&gt;
&lt;td&gt;eni-921a6ecb&lt;/td&gt;
&lt;td&gt;10&amp;#46;175.1.194&lt;/td&gt;
&lt;td&gt;54&amp;#46;64.192.17&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;ENI(internal)&lt;/td&gt;
&lt;td&gt;eni-6304703a&lt;/td&gt;
&lt;td&gt;10&amp;#46;175.2.195&lt;/td&gt;
&lt;td&gt;&amp;#8211;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;　そして、新規取得した54.64.192.17を割り当てた10.175.1.194を利用して、バーチャルIPアドレスを作成します。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/01/aws-fg-2.png&#34; alt=&#34;enter image description here&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ポリシー:ec17bdc7c38ff198df2edaa2953430eb&#34;&gt;ポリシー&lt;/h2&gt;

&lt;p&gt;　ネットワークやNATの設定はAWSの仕様を意識する必要がありますが、ポリシーの設定はFortiGate-VM単体の設定ですので、普通のFortiGateと同じです。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;サンプル&lt;/strong&gt;　 　&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/01/aws-fg-4.png&#34; alt=&#34;enter image description here&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このように設定すると、以下の動作になります。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;外部から54.64.192.17へのすべての通信が、AWSによって10.175.1.194にNATされ、さらにFortiGate-VMでNATされてEC2：10.175.2.152に到達する&lt;/li&gt;
&lt;li&gt;EC2：10.175.2.152から外部へのアクセスは、FortiGateによって10.175.1.194でNATされ、さらにAWSによって54.64.192.17にNATされて外部に到達する。&lt;/li&gt;
&lt;li&gt;internal_subnetから外部へのアクセスは、FortiGateによって10.175.1.195でNATされ、さらにAWSによって54.65.151.103にNATされて外部に到達する。&lt;/li&gt;
&lt;li&gt;それ以外の通信はすべて拒否する。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ipアドレスの制限:ec17bdc7c38ff198df2edaa2953430eb&#34;&gt;IPアドレスの制限&lt;/h2&gt;

&lt;p&gt;　バーチャルIP用のアドレスを確保するためには、ENIにIPアドレスを追加割り当てする必要があります。ただし、ENIに割り当てられるIPアドレスはインスタンスタイプによって上限があります。（&lt;a href=&#34;http://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/using-eni.html#AvailableIpPerENI&#34;&gt;参考：インスタンスタイプあたりの ENI ごとのプライベート IP アドレス&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;　今回利用しているt3.mediumは最大6個になります。EIPはENIのプライベートアドレスに割り当てる必要がありますので、取得できるEIPの数も最大6個になってしまいます。つまり、このt3.mediumのFortiGate-VMを利用すると、最大6個のIPアドレスしか外部公開できなくなります&amp;#8230;インスタンスタイプを上げても最大30個です。これは微妙&amp;#8230;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/01/aws-fg-5.png&#34; alt=&#34;enter image description here&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AWSにFortiGateをデプロイしてみた（ログ出力編）</title>
      <link>http://aimless.jp/blog/archives/2378</link>
      <pubDate>Sat, 24 Jan 2015 00:00:00 +0000</pubDate>
      
      <guid>http://aimless.jp/blog/archives/2378</guid>
      <description>

&lt;p&gt;AWS上にデプロイしたForiGate-VMは、デフォルトではログが出力されなかったので、ログを出力するために必要な作業をメモします。&lt;/p&gt;

&lt;h2 id=&#34;初期状態:0369e224a48532743f250f58f50b7a06&#34;&gt;初期状態&lt;/h2&gt;

&lt;p&gt;　デプロイ直後の状況は以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メモリログが無効になっている&lt;/li&gt;
&lt;li&gt;ディスクログは有効だが、そもそもディスクにパーティションが作られていない&lt;/li&gt;
&lt;/ul&gt;

&lt;script src=&#34;https://gist.github.com/kongou-ae/e3fb5b701e6744553d38.js&#34;&gt;&lt;/script&gt;

&lt;p&gt;　FortiGate-VMには、マーケットプレイスからポチポチデプロイしたときにデフォルトで選択されているEBSを搭載しているのですが、利用できていません。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;EBS選択画面&lt;/strong&gt; &lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/01/aws-fg-6.png&#34; alt=&#34;enter image description here&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;FortiGateの管理画面&lt;/strong&gt; &lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/01/aws-fg-8.png&#34; alt=&#34;enter image description here&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;対処方法:0369e224a48532743f250f58f50b7a06&#34;&gt;対処方法&lt;/h2&gt;

&lt;p&gt;　メモリログを有効にしたい場合はCLIから設定を変更します。ディスクログを有効にする場合は、CLIからディスクをフォーマットします。&lt;/p&gt;

&lt;script src=&#34;https://gist.github.com/kongou-ae/bf9799c6dfc97a24cf4f.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;動作確認:0369e224a48532743f250f58f50b7a06&#34;&gt;動作確認&lt;/h2&gt;

&lt;p&gt;　管理画面上でもディスクを認識するようになりました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/01/aws-fg-9.png&#34; alt=&#34;enter image description here&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　ログ確認画面の表示をディスクに切り替えます。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/01/aws-fg-10.png&#34; alt=&#34;enter image description here&#34; /&gt;&lt;/p&gt;

&lt;p&gt;　無事、ディスクに保存されているログを確認出来るようになりました。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://aimless.jp/blog/wp-content/uploads/2015/01/aws-fg-11.png&#34; alt=&#34;enter image description here&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>